--- /dev/null
+++ b/src/ap/wds_wpa.c
@@ -0,0 +1,528 @@
+#include "includes.h"
+#include "common.h"
+#include "drivers/driver.h"
+#include "hostapd.h"
+#include "sta_info.h"
+#include "ap_drv_ops.h"
+#include "ieee802_11.h"
+#include "accounting.h"
+#include "beacon.h"
+#include "ap_mlme.h"
+#include "wpa_auth_ie.h"
+#include "wpa_auth.h"
+#include "rsn_supp/wpa.h"
+#include "utils/eloop.h"
+#include "wds_wpa.h"
+
+
+struct ltq_wpa_supplicant {
+  enum wpa_states wpa_state;
+  struct hostapd_data *hapd;
+  struct sta_info *sta;
+};
+
+u16 check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
+         const u8 *ies, size_t ies_len, int reassoc);
+
+
+/**
+ * wpa_supplicant_state_txt - Get the connection state name as a text string
+ * @state: State (wpa_state; WPA_*)
+ * Returns: The state name as a printable text string
+ */
+const char * ltq_wds_wpa_state_txt(enum wpa_states state)
+{
+  switch (state) {
+  case WPA_DISCONNECTED:
+    return "DISCONNECTED";
+  case WPA_INACTIVE:
+    return "INACTIVE";
+  case WPA_INTERFACE_DISABLED:
+    return "INTERFACE_DISABLED";
+  case WPA_SCANNING:
+    return "SCANNING";
+  case WPA_AUTHENTICATING:
+    return "AUTHENTICATING";
+  case WPA_ASSOCIATING:
+    return "ASSOCIATING";
+  case WPA_ASSOCIATED:
+    return "ASSOCIATED";
+  case WPA_4WAY_HANDSHAKE:
+    return "4WAY_HANDSHAKE";
+  case WPA_GROUP_HANDSHAKE:
+    return "GROUP_HANDSHAKE";
+  case WPA_COMPLETED:
+    return "COMPLETED";
+  default:
+    return "UNKNOWN";
+  }
+}
+
+static void ltq_supplicant_timeout(void *eloop_ctx, void *timeout_ctx)
+{
+  struct ltq_wpa_supplicant *supplicant = eloop_ctx;
+  struct hostapd_data *hapd = supplicant->hapd;
+  struct sta_info *sta = supplicant->sta;
+
+  wpa_msg(hapd, MSG_INFO, "Authentication with " MACSTR " timed out.",
+    MAC2STR(sta->addr));
+  ap_sta_disconnect(hapd, sta, sta->addr, WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT);
+#if 0
+  /* implementation without STA disconnect */
+  hostapd_drv_sta_deauth(hapd, sta->addr, WLAN_REASON_DEAUTH_LEAVING);
+  wpa_sm_key_request(sta->wpa, 0, 1);
+  hostapd_drv_poll_client(hapd, hapd->own_addr, sta->addr,
+    sta->flags & WLAN_STA_WMM);
+  eloop_register_timeout(5, 0, ltq_supplicant_timeout, supplicant, NULL);
+#endif
+}
+
+
+static void ltq_supplicant_sta_check(void *eloop_ctx, void *timeout_ctx)
+{
+  struct hostapd_data *hapd = eloop_ctx;
+  int i;
+
+  for(i = 0; i < hapd->conf->num_wds_wpa_sta; i++) {
+    ltq_wds_wpa_add(hapd, hapd->conf->wds_wpa_sta[i].addr);
+  }
+  eloop_register_timeout(10, 0, ltq_supplicant_sta_check, hapd, NULL);
+}
+
+
+static enum wpa_states ltq_wds_wpa_get_state(void *ctx)
+{
+  struct ltq_wpa_supplicant *supplicant = ctx;
+
+  return supplicant->wpa_state;
+}
+
+static void ltq_wds_wpa_set_state(void *ctx, enum wpa_states state)
+{
+  struct ltq_wpa_supplicant *supplicant = ctx;
+
+  wpa_printf(MSG_DEBUG, "SUPP: %s addr=" MACSTR " wpa_state: %s",
+    __func__, MAC2STR(supplicant->sta->addr),
+    ltq_wds_wpa_state_txt(state));
+  supplicant->wpa_state = state;
+}
+
+static void ltq_wds_wpa_deauthenticate(void * ctx, int reason_code)
+{
+  struct ltq_wpa_supplicant *supplicant = ctx;
+  struct hostapd_data *hapd = supplicant->hapd;
+  struct sta_info *sta = supplicant->sta;
+
+  wpa_msg(hapd, MSG_INFO, "Deauthenticate " MACSTR,
+    MAC2STR(sta->addr));
+  ap_sta_disconnect(hapd, sta, sta->addr, WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT);
+}
+
+static void * ltq_wds_wpa_get_network_ctx(void *ctx)
+{
+  return ctx;
+}
+
+static u8 * ltq_wds_wpa_alloc_eapol(void *ctx, u8 type,
+      const void *data, u16 data_len,
+      size_t *msg_len, void **data_pos)
+{
+  struct ieee802_1x_hdr *hdr;
+
+  *msg_len = sizeof(*hdr) + data_len;
+  hdr = os_malloc(*msg_len);
+  if (hdr == NULL)
+    return NULL;
+
+  hdr->version = 2;
+  hdr->type = type;
+  hdr->length = host_to_be16(data_len);
+
+  if (data)
+    os_memcpy(hdr + 1, data, data_len);
+  else
+    os_memset(hdr + 1, 0, data_len);
+
+  if (data_pos)
+    *data_pos = hdr + 1;
+
+  return (u8 *) hdr;
+}
+
+static int ltq_wds_wpa_get_bssid(void *ctx, u8 *bssid)
+{
+  struct ltq_wpa_supplicant *supplicant = ctx;
+
+  wpa_printf(MSG_DEBUG, "ltq_wds_wpa_get_bssid: " MACSTR,
+    MAC2STR(supplicant->sta->addr));
+  os_memcpy(bssid, supplicant->sta->addr, ETH_ALEN);
+
+  return 0;
+}
+
+static int ltq_wds_wpa_eth_send(void *ctx, const u8 *dest, u16 proto,
+  const u8 *buf, size_t len)
+{
+  struct ltq_wpa_supplicant *supplicant = ctx;
+  struct hostapd_data *hapd = supplicant->hapd;
+  struct sta_info *sta = supplicant->sta;
+
+  return hostapd_drv_hapd_send_eapol(hapd, dest, buf, len,
+    0, hostapd_sta_flags_to_drv(sta->flags));
+}
+
+static int ltq_wds_wpa_get_beacon_ie(void *ctx)
+{
+  wpa_printf(MSG_DEBUG, "SUPP: %s NOT IMPLEMENTED!!!", __func__);
+  return -1;
+}
+
+static int ltq_wds_wpa_set_key(void *ctx, enum wpa_alg alg,
+  const u8 *addr, int key_idx, int set_tx,
+  const u8 *seq, size_t seq_len,
+  const u8 *key, size_t key_len)
+{
+  struct ltq_wpa_supplicant *supplicant = ctx;
+  struct hostapd_data *hapd = supplicant->hapd;
+  const char *ifname = hapd->conf->iface;
+
+  wpa_printf(MSG_DEBUG, "SUPP: %s(alg=%d addr=" MACSTR " key_idx=%d "
+    "set_tx=%d)", __func__, alg, MAC2STR(addr), key_idx, set_tx);
+  if (key_idx != 0) {
+    wpa_printf(MSG_INFO, "SUPP: %s. Ignoring broadcast key set request",
+      __func__);
+    return 0;
+  }
+  return hostapd_drv_set_key(ifname, hapd, alg, addr, key_idx, set_tx, seq,
+    seq_len, key, key_len);
+}
+
+static int ltq_wds_wpa_set_protection(void *ctx, const u8 *addr,
+  int protection_type, int key_type)
+{
+  struct ltq_wpa_supplicant *supplicant = ctx;
+  struct hostapd_data *hapd = supplicant->hapd;
+  struct sta_info *sta = supplicant->sta;
+
+  wpa_printf(MSG_DEBUG, "SUPP: %s(addr=" MACSTR " protection_type=%d "
+       "key_type=%d)",
+       __func__, MAC2STR(addr), protection_type, key_type);
+
+  return hostapd_set_authorized(hapd, sta, 1);
+}
+
+static void ltq_wds_wpa_cancel_auth_timeout(void *ctx)
+{
+  struct ltq_wpa_supplicant *supplicant = ctx;
+  struct sta_info *sta = supplicant->sta;
+
+  wpa_printf(MSG_DEBUG, "SUPP: Cancelling authentication timeout (addr=" MACSTR")",
+       MAC2STR(sta->addr));
+
+  eloop_cancel_timeout(ltq_supplicant_timeout, ctx, NULL);
+
+}
+
+static int ltq_wds_wpa_add_pmkid(void *ctx, const u8 *bssid, const u8 *pmkid)
+{
+  wpa_printf(MSG_DEBUG, "SUPP: %s NOT IMPLEMENTED!!!", __func__);
+  return -1;
+}
+
+
+static int ltq_wds_wpa_remove_pmkid(void *ctx, const u8 *bssid, const u8 *pmkid)
+{
+  wpa_printf(MSG_DEBUG, "SUPP: %s NOT IMPLEMENTED!!!", __func__);
+  return -1;
+}
+
+static void ltq_wds_wpa_set_config_blob(void *ctx, struct wpa_config_blob *blob)
+{
+  wpa_printf(MSG_DEBUG, "SUPP: %s NOT IMPLEMENTED!!!", __func__);
+}
+
+static const struct wpa_config_blob* ltq_wds_wpa_get_config_blob(void *ctx, const char *name)
+{
+  wpa_printf(MSG_DEBUG, "SUPP: %s NOT IMPLEMENTED!!!", __func__);
+  return NULL;
+}
+
+static int ltq_wds_wpa_update_ft_ies(void *ctx, const u8 *md, const u8 *ies,
+  size_t ies_len)
+{
+  wpa_printf(MSG_DEBUG, "SUPP: %s NOT IMPLEMENTED!!!", __func__);
+  return -1;
+}
+
+static int ltq_wds_wpa_send_ft_action(void *ctx, u8 action, const u8 *target_ap,
+  const u8 *ies, size_t ies_len)
+{
+  wpa_printf(MSG_DEBUG, "SUPP: %s NOT IMPLEMENTED!!!", __func__);
+  return -1;
+}
+
+static int ltq_wds_wpa_mark_authenticated(void *ctx, const u8 *target_ap)
+{
+  wpa_printf(MSG_DEBUG, "SUPP: %s NOT IMPLEMENTED!!!", __func__);
+  return -1;
+}
+
+static void ltq_wds_wpa_set_rekey_offload(void *ctx, const u8 *kek, size_t kek_len,
+  const u8 *kck, size_t kck_len,
+  const u8 *replay_ctr)
+{
+  wpa_printf(MSG_DEBUG, "SUPP: %s NOT IMPLEMENTED!!!", __func__);
+}
+
+static int ltq_wds_wpa_key_mgmt_set_pmk(void *ctx, const u8 *pmk, size_t pmk_len)
+{
+  wpa_printf(MSG_DEBUG, "SUPP: %s NOT IMPLEMENTED!!!", __func__);
+  return -1;
+}
+
+int ltq_wds_wpa_add(struct hostapd_data *hapd, const u8 *src)
+{
+  struct sta_info *sta;
+  struct wpa_driver_ap_params params;
+  struct ieee80211_ht_capabilities ht_cap;
+  struct ieee80211_vht_capabilities vht_cap;
+  struct ieee80211_mgmt *head;
+  u8 *body;
+  size_t head_len;
+  struct wpa_sm_ctx *wctx = NULL;
+  struct ltq_wpa_supplicant *supplicant = NULL;
+  u8 wpa_ie[80];
+  size_t wpa_ie_len;
+  int wps_state;
+
+  /* Check that station doesn't exist. We are allocating several
+   * structures here. If we would call it with existing station,
+   * memory leak would occur. */
+  sta = ap_get_sta(hapd, src);
+  if (sta)
+    return 0;
+
+  wpa_printf(MSG_DEBUG, "ltq_wds_wpa_add: adding WDS WPA station " MACSTR,
+    MAC2STR(src));
+
+  sta = ap_sta_add(hapd, src);
+  if (!sta) {
+    wpa_printf(MSG_ERROR, "Unable to handle new sta");
+    return -1;
+  }
+  sta->flags |= WLAN_STA_ASSOC | WLAN_STA_ASSOC_REQ_OK;
+
+  if (ieee802_11_build_ap_params(hapd, &params) < 0)
+    goto free_sta;
+  /* length of variable part of beacon head */
+  head_len = params.head_len - ((size_t)&head->u.beacon.variable[0] - (size_t)head);
+  body = os_zalloc(head_len + params.tail_len);
+  if (body == NULL) {
+    wpa_printf(MSG_ERROR, "Out of memory");
+    goto free_ap_params;
+  }
+  head = (struct ieee80211_mgmt *)params.head;
+  os_memcpy(body, &head->u.beacon.variable[0], head_len);
+  os_memcpy(body + head_len, params.tail, params.tail_len);
+  wpa_hexdump(MSG_DEBUG, "Beacon head and tail", body,
+    head_len + params.tail_len);
+  /* disable WPS temporary, otherwise wpa_sm won't be created */
+  wps_state = hapd->conf->wps_state;
+  hapd->conf->wps_state = 0;
+  check_assoc_ies(hapd, sta, body, head_len + params.tail_len, 0);
+  hapd->conf->wps_state = wps_state;
+
+  if (hapd->conf->wpa &&
+    os_memcmp(hapd->own_addr, src, sizeof(hapd->own_addr)) < 0) {
+    /* we are supplicant */
+    wctx = os_zalloc(sizeof(*wctx));
+    if (wctx == NULL) {
+      wpa_printf(MSG_ERROR, "Out of memory");
+      goto free_body;
+    }
+    supplicant = os_zalloc(sizeof(*supplicant));
+    if (supplicant == NULL) {
+      wpa_printf(MSG_ERROR, "Out of memory");
+      os_free(wctx);
+      goto free_body;
+    }
+    supplicant->hapd = hapd;
+    supplicant->sta = sta;
+    wctx->ctx = supplicant;
+    wctx->msg_ctx = hapd;
+    wctx->get_state = ltq_wds_wpa_get_state;
+    wctx->set_state = ltq_wds_wpa_set_state;
+    wctx->deauthenticate = ltq_wds_wpa_deauthenticate;
+    wctx->get_network_ctx = ltq_wds_wpa_get_network_ctx;
+    wctx->alloc_eapol = ltq_wds_wpa_alloc_eapol;
+    wctx->get_bssid = ltq_wds_wpa_get_bssid;
+    wctx->ether_send = ltq_wds_wpa_eth_send;
+    wctx->get_beacon_ie = ltq_wds_wpa_get_beacon_ie;
+    wctx->set_key = ltq_wds_wpa_set_key;
+    wctx->mlme_setprotection = ltq_wds_wpa_set_protection;
+    wctx->cancel_auth_timeout = ltq_wds_wpa_cancel_auth_timeout;
+    wctx->add_pmkid = ltq_wds_wpa_add_pmkid;
+    wctx->remove_pmkid = ltq_wds_wpa_remove_pmkid;
+    wctx->set_config_blob = ltq_wds_wpa_set_config_blob;
+    wctx->get_config_blob = ltq_wds_wpa_get_config_blob;
+    wctx->update_ft_ies = ltq_wds_wpa_update_ft_ies;
+    wctx->send_ft_action = ltq_wds_wpa_send_ft_action;
+    wctx->mark_authenticated = ltq_wds_wpa_mark_authenticated;
+    wctx->set_rekey_offload = ltq_wds_wpa_set_rekey_offload;
+    wctx->key_mgmt_set_pmk = ltq_wds_wpa_key_mgmt_set_pmk;
+    sta->wpa = wpa_sm_init(wctx);
+    if (sta->wpa == NULL) {
+      wpa_printf(MSG_ERROR, "Out of memory");
+      os_free(wctx);
+      os_free(supplicant);
+      goto free_body;
+    }
+    /* wpa_sm_set_param(sta->wpa, WPA_PARAM_PROTO, hapd->conf->wpa); */
+    wpa_sm_set_param(sta->wpa, WPA_PARAM_PROTO, WPA_PROTO_RSN);
+    wpa_sm_set_param(sta->wpa, WPA_PARAM_RSN_ENABLED,
+      !!(hapd->conf->wpa & (WPA_PROTO_RSN | WPA_PROTO_OSEN)));
+    wpa_sm_set_param(sta->wpa, WPA_PARAM_KEY_MGMT, hapd->conf->wpa_key_mgmt);
+    /* wpa_sm_set_param(sta->wpa, WPA_PARAM_PAIRWISE, hapd->conf->wpa_pairwise); */
+    wpa_sm_set_param(sta->wpa, WPA_PARAM_PAIRWISE, WPA_CIPHER_CCMP);
+   /* wpa_sm_set_param(sta->wpa, WPA_PARAM_GROUP, hapd->conf->wpa_group);*/
+    wpa_sm_set_param(sta->wpa, WPA_PARAM_GROUP, WPA_CIPHER_CCMP);
+    wpa_sm_set_own_addr(sta->wpa, hapd->own_addr);
+    wpa_ie_len = sizeof(wpa_ie);
+    wpa_sm_set_assoc_wpa_ie_default(sta->wpa, wpa_ie, &wpa_ie_len);
+    if (wpa_modify_wpa_ie_rsn(wpa_ie, wpa_ie_len, RSN_SELECTOR(0x00, 0x10, 0x18, 0), 0))
+      goto free_body;
+    wpa_ie[1] -= 2;
+    wpa_ie_len -= 2;
+    if (wpa_sm_set_assoc_wpa_ie(sta->wpa, wpa_ie, wpa_ie_len))
+      goto free_body;
+    if (wpa_sm_set_ap_wpa_ie(sta->wpa, wpa_ie, wpa_ie_len))
+      goto free_body;
+    wpa_sm_set_pmk(sta->wpa, hapd->conf->ssid.wpa_psk->psk, PMK_LEN, NULL, NULL);
+  }
+
+  if (hostapd_get_aid(hapd, sta) < 0) {
+    hostapd_logger(hapd, src, HOSTAPD_MODULE_IEEE80211,
+      HOSTAPD_LEVEL_INFO, "No room for more AIDs");
+    goto free_body;
+  }
+  hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+    HOSTAPD_LEVEL_DEBUG,
+    "association OK (aid %d)", sta->aid);
+  /* Stop previous accounting session, if one is started, and allocate
+   * new session id for the new session. */
+  accounting_sta_stop(hapd, sta);
+  hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+    HOSTAPD_LEVEL_INFO,
+    "associated (aid %d)",
+    sta->aid);
+
+  sta->capability = le_to_host16(head->u.beacon.capab_info);
+
+  mlme_associate_indication(hapd, sta);
+#ifdef CONFIG_IEEE80211W
+  sta->sa_query_timed_out = 0;
+#endif /* CONFIG_IEEE80211W */
+
+#ifdef CONFIG_IEEE80211N
+  if (sta->flags & WLAN_STA_HT)
+    hostapd_get_ht_capab(hapd, sta->ht_capabilities, &ht_cap);
+#endif /* CONFIG_IEEE80211N */
+#ifdef CONFIG_IEEE80211AC
+  if (sta->flags & WLAN_STA_VHT)
+    hostapd_get_vht_capab(hapd, sta->vht_capabilities, &vht_cap);
+#endif /* CONFIG_IEEE80211AC */
+
+  printf("Sta flags 1 0x%08X\n", sta->flags);
+  sta->ssi_signal = -5000;
+  if (sta->wpa_sm == NULL)
+    sta->flags |= WLAN_STA_AUTHORIZED;
+  else if (sta->wpa != NULL) {
+    /* Free authenticator SM, if we are supplicant. */
+    wpa_auth_sta_deinit(sta->wpa_sm);
+    sta->wpa_sm = NULL;
+    wpa_printf(MSG_DEBUG, "ltq_wds_wpa_add: working with WDS WPA station "
+      MACSTR " as supplicant",
+      MAC2STR(src));
+  } else {
+    wpa_printf(MSG_DEBUG, "ltq_wds_wpa_add: working with WDS WPA station "
+      MACSTR " as authenticator",
+      MAC2STR(src));
+  }
+
+  printf("Sta flags 2 0x%08X\n", sta->flags);
+  if (hostapd_sta_add(hapd, sta->addr, sta->aid, sta->capability,
+          sta->supported_rates, sta->supported_rates_len,
+          sta->listen_interval,
+          sta->flags & WLAN_STA_HT ? &ht_cap : NULL,
+          sta->flags & WLAN_STA_VHT ? &vht_cap : NULL,
+          sta->flags, sta->qosinfo, sta->vht_opmode,
+          sta->p2p_ie ? 1 : 0, 0, sta->last_assoc_req,
+          sta->last_assoc_req_len, sta->ssi_signal)) {
+    hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+             HOSTAPD_LEVEL_NOTICE,
+             "Could not add STA to kernel driver");
+    goto free_body;
+  }
+  printf("Sta flags 3 0x%08X\n", sta->flags);
+  if (sta->wpa_sm &&
+    wpa_modify_wpa_ie(sta->wpa_sm, RSN_SELECTOR(0x00, 0x10, 0x18, 0), 0, -2)) {
+    hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+             HOSTAPD_LEVEL_NOTICE,
+             "Could not modify WPA RSN IE");
+    goto sta_remove;
+  }
+  os_free(body);
+  ieee802_11_free_ap_params(&params);
+
+  wpa_auth_sm_event(sta->wpa_sm, WPA_ASSOC);
+  if (sta->wpa) {
+    supplicant->wpa_state = WPA_ASSOCIATED;
+    wpa_printf(MSG_DEBUG, "Setting authentication timeout: 5 sec");
+    eloop_cancel_timeout(ltq_supplicant_timeout, supplicant, NULL);
+    eloop_register_timeout(20, 0, ltq_supplicant_timeout, supplicant, NULL);
+  }
+  wpa_sm_notify_assoc(sta->wpa, src);
+  if (sta->wpa_sm)
+    hapd->new_assoc_sta_cb(hapd, sta, 1);
+  if (sta->wpa)
+    wpa_sm_key_request(sta->wpa, 0, 1);
+  hostapd_drv_poll_client(hapd, hapd->own_addr, src, sta->flags & WLAN_STA_WMM);
+
+  return 0;
+
+sta_remove:
+  hostapd_drv_sta_remove(hapd, src);
+free_body:
+  os_free(body);
+free_ap_params:
+  ieee802_11_free_ap_params(&params);
+free_sta:
+  ap_free_sta(hapd, sta);
+  return -1;
+}
+
+int ltq_wds_wpa_init(struct hostapd_data *hapd)
+{
+  int i, ret;
+
+  wpa_printf(MSG_DEBUG, "wds_wpa_init");
+
+  for(i = 0; i < hapd->conf->num_wds_wpa_sta; i++) {
+    ret = hostapd_drv_set_wds_wpa_sta(hapd, hapd->conf->wds_wpa_sta[i].addr, 0);
+    if (ret)
+      return ret;
+  }
+  return eloop_register_timeout(10, 0, ltq_supplicant_sta_check, hapd, NULL);
+}
+
+void ltq_wds_wpa_deinit(struct hostapd_data *hapd)
+{
+  int i;
+
+  wpa_printf(MSG_DEBUG, "wds_wpa_deinit");
+
+  eloop_cancel_timeout(ltq_supplicant_sta_check, hapd, NULL);
+  for(i = 0; i < hapd->conf->num_wds_wpa_sta; i++)
+    hostapd_drv_set_wds_wpa_sta(hapd, hapd->conf->wds_wpa_sta[i].addr, 1);
+}
+
--- /dev/null
+++ b/src/ap/wds_wpa.h
@@ -0,0 +1,8 @@
+#ifndef WDS_WPA_H
+#define WDS_WPA_H
+
+int ltq_wds_wpa_init(struct hostapd_data *hapd);
+void ltq_wds_wpa_deinit(struct hostapd_data *hapd);
+int ltq_wds_wpa_add(struct hostapd_data *hapd, const u8 *src);
+
+#endif /* WDS_WPA_H */
--- a/hostapd/Makefile
+++ b/hostapd/Makefile
@@ -290,6 +290,9 @@ endif
 ifdef CONFIG_IEEE80211R
 CFLAGS += -DCONFIG_IEEE80211R
 OBJS += ../src/ap/wpa_auth_ft.o
+ifdef CONFIG_WDS_WPA
+OBJS += ../src/rsn_supp/wpa_ft.o
+endif
 NEED_SHA256=y
 NEED_AES_OMAC1=y
 NEED_AES_UNWRAP=y
@@ -1014,6 +1017,16 @@ ifdef CONFIG_FANCY_LOG
 CFLAGS += -DCONFIG_FANCY_LOG
 endif
 
+ifdef CONFIG_WDS_WPA
+CFLAGS += -DCONFIG_WDS_WPA
+OBJS += ../src/ap/wds_wpa.o
+OBJS += ../src/rsn_supp/wpa.o
+OBJS += ../src/rsn_supp/preauth.o
+OBJS += ../src/rsn_supp/pmksa_cache.o
+OBJS += ../src/rsn_supp/peerkey.o
+OBJS += ../src/rsn_supp/wpa_ie.o
+endif
+
 ALL=hostapd hostapd_cli
 
 all: verify_config $(ALL)
--- a/hostapd/.config
+++ b/hostapd/.config
@@ -348,3 +348,6 @@ CONFIG_MBO=y
 # Include internal line edit mode in hostapd_cli. This can be used to provide
 # limited command line editing and history support.
 CONFIG_WPA_CLI_EDIT=y
+
+# Support of Asus WDS. Requires WPA support (enabled by default).
+CONFIG_WDS_WPA=y
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -45,6 +45,9 @@
 #include "mbo_ap.h"
 #include "rrm.h"
 #include "taxonomy.h"
+#ifdef CONFIG_WDS_WPA
+#include "wds_wpa.h"
+#endif
 
 
 u8 * hostapd_eid_supp_rates(struct hostapd_data *hapd, u8 *eid)
@@ -1508,6 +1511,37 @@ static u16 check_wmm(struct hostapd_data
 	return WLAN_STATUS_SUCCESS;
 }
 
+#ifdef CONFIG_WDS_WPA
+static u16 check_wmm_wds(struct hostapd_data *hapd, struct sta_info *sta,
+         const u8 *wmm_ie, size_t wmm_ie_len)
+{
+  sta->flags &= ~WLAN_STA_WMM;
+  sta->qosinfo = 0;
+  if (wmm_ie && hapd->conf->wmm_enabled) {
+    struct wmm_information_element *wmm;
+
+    if (!hostapd_eid_wmm_valid_wds(hapd, wmm_ie, wmm_ie_len)) {
+      hostapd_logger(hapd, sta->addr,
+               HOSTAPD_MODULE_WPA,
+               HOSTAPD_LEVEL_DEBUG,
+               "invalid WMM element in association "
+               "request");
+      return WLAN_STATUS_UNSPECIFIED_FAILURE;
+    }
+
+    sta->flags |= WLAN_STA_WMM;
+    wmm = (struct wmm_information_element *) wmm_ie;
+    sta->qosinfo = wmm->qos_info;
+
+    /* clear UAPSD if it unsupported by BSS */
+    if (!hapd->conf->wmm_uapsd)
+      sta->qosinfo &= ~WMM_QOSINFO_STA_AC_MASK;
+
+  }
+  return WLAN_STATUS_SUCCESS;
+}
+#endif
+
 
 u16 copy_supp_rates(struct hostapd_data *hapd, struct sta_info *sta,
 			   struct ieee802_11_elems *elems)
@@ -1561,7 +1595,7 @@ static u16 check_ext_capab(struct hostap
 }
 
 
-static u16 check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
+u16 check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 			   const u8 *ies, size_t ies_len, int reassoc)
 {
 	struct ieee802_11_elems elems;
@@ -1580,6 +1614,12 @@ static u16 check_assoc_ies(struct hostap
 	resp = check_ssid(hapd, sta, elems.ssid, elems.ssid_len);
 	if (resp != WLAN_STATUS_SUCCESS)
 		return resp;
+#ifdef CONFIG_WDS_WPA
+  if (hostapd_maclist_found(hapd->conf->wds_wpa_sta,
+    hapd->conf->num_wds_wpa_sta, sta->addr, NULL))
+    resp = check_wmm_wds(hapd, sta, elems.wmm, elems.wmm_len);
+  else
+#endif
 	resp = check_wmm(hapd, sta, elems.wmm, elems.wmm_len);
 	if (resp != WLAN_STATUS_SUCCESS)
 		return resp;
@@ -3271,11 +3311,18 @@ void ieee802_11_rx_from_unknown(struct h
 		return;
 	}
 
-	if (sta && (sta->flags & WLAN_STA_AUTH))
+	if (sta && (sta->flags & WLAN_STA_AUTH)) {
 		hostapd_drv_sta_disassoc(
 			hapd, src,
 			WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
-	else
+		return;
+	}
+#ifdef CONFIG_WDS_WPA
+  if (hostapd_maclist_found(hapd->conf->wds_wpa_sta,
+    hapd->conf->num_wds_wpa_sta, src, NULL))
+    ltq_wds_wpa_add(hapd, src);
+    else
+#endif
 		hostapd_drv_sta_deauth(
 			hapd, src,
 			WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
--- a/src/common/wpa_common.h
+++ b/src/common/wpa_common.h
@@ -449,5 +449,8 @@ int wpa_parse_cipher(const char *value);
 int wpa_write_ciphers(char *start, char *end, int ciphers, const char *delim);
 int wpa_select_ap_group_cipher(int wpa, int wpa_pairwise, int rsn_pairwise);
 unsigned int wpa_mic_len(int akmp);
+#ifdef CONFIG_WDS_WPA
+int wpa_modify_wpa_ie_rsn(u8 *rsn_ie, size_t rsn_ie_len, u32 group_suite, u16 capab);
+#endif
 
 #endif /* WPA_COMMON_H */
--- a/src/ap/wpa_auth_ie.h
+++ b/src/ap/wpa_auth_ie.h
@@ -53,5 +53,7 @@ int wpa_parse_kde_ies(const u8 *buf, siz
 u8 * wpa_add_kde(u8 *pos, u32 kde, const u8 *data, size_t data_len,
 		 const u8 *data2, size_t data2_len);
 int wpa_auth_gen_wpa_ie(struct wpa_authenticator *wpa_auth);
-
+#ifdef CONFIG_WDS_WPA
+int wpa_modify_wpa_ie(struct wpa_state_machine *sm, u32 group_suite, u16 capab, int size);
+#endif
 #endif /* WPA_AUTH_IE_H */
--- a/src/ap/sta_info.h
+++ b/src/ap/sta_info.h
@@ -151,6 +151,7 @@ struct sta_info {
 	u8 *challenge; /* IEEE 802.11 Shared Key Authentication Challenge */
 
 	struct wpa_state_machine *wpa_sm;
+	struct wpa_sm *wpa;
 	struct rsn_preauth_interface *preauth_iface;
 
 	int vlan_id; /* 0: none, >0: VID */
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -36,6 +36,9 @@
 #include "ndisc_snoop.h"
 #include "sta_info.h"
 #include "vlan.h"
+#ifdef CONFIG_WDS_WPA
+#include "rsn_supp/wpa.h"
+#endif
 
 static void ap_sta_remove_in_other_bss(struct hostapd_data *hapd,
 				       struct sta_info *sta);
@@ -276,6 +279,9 @@ void ap_free_sta(struct hostapd_data *ha
 
 	ieee802_1x_free_station(hapd, sta);
 	wpa_auth_sta_deinit(sta->wpa_sm);
+#ifdef CONFIG_WDS_WPA
+	wpa_sm_deinit(sta->wpa);
+#endif
 	rsn_preauth_free_station(hapd, sta);
 #ifndef CONFIG_NO_RADIUS
 	if (hapd->radius)
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -3955,6 +3955,15 @@ static int hostapd_config_fill(struct ho
 			hostapd_atf_read_config (&conf->atf_cfg, conf->atf_config_file);
 		else
 			hostapd_atf_clean_config(&conf->atf_cfg);
+#ifdef CONFIG_WDS_WPA
+  } else if (os_strcmp(buf, "wds_wpa_sta_file") == 0) {
+    if (hostapd_config_read_maclist(pos, &bss->wds_wpa_sta,
+      &bss->num_wds_wpa_sta)) {
+      wpa_printf(MSG_ERROR, "Line %d: Failed to read wds_wpa_sta_file '%s'",
+        line, pos);
+      return 1;
+    }
+#endif
 	} else {
 		wpa_printf(MSG_ERROR,
 			   "Line %d: unknown configuration item '%s'",
--- a/src/ap/ap_config.c
+++ b/src/ap/ap_config.c
@@ -706,6 +706,10 @@ void hostapd_config_free_bss(struct host
 	os_free(conf->no_probe_resp_if_seen_on);
 	os_free(conf->no_auth_if_seen_on);
 
+#ifdef CONFIG_WDS_WPA
+  os_free(conf->wds_wpa_sta);
+#endif
+
 	os_free(conf);
 }
 
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -603,6 +603,11 @@ struct hostapd_bss_config {
 
 	int ftm_responder;
 	int ftm_initiator;
+
+#ifdef CONFIG_WDS_WPA
+	struct mac_acl_entry *wds_wpa_sta;
+	int num_wds_wpa_sta;
+#endif
 };
 
 
--- a/src/ap/ap_drv_ops.h
+++ b/src/ap/ap_drv_ops.h
@@ -466,4 +466,14 @@ static inline int hostapd_drv_get_capa(s
   return hapd->driver->get_capa(hapd->drv_priv, capa);
 }
 
+#ifdef CONFIG_WDS_WPA
+static inline int hostapd_drv_set_wds_wpa_sta(struct hostapd_data *hapd,
+  const u8 *addr, const u8 remove)
+{
+  if (hapd->driver == NULL || hapd->driver->set_wds_wpa_sta == NULL)
+    return -ENOTSUP;
+
+  return hapd->driver->set_wds_wpa_sta(hapd->drv_priv, addr, remove);
+}
+#endif
 #endif /* AP_DRV_OPS */
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -47,6 +47,9 @@
 #include "ndisc_snoop.h"
 #include "neighbor_db.h"
 #include "rrm.h"
+#ifdef CONFIG_WDS_WPA
+#include "wds_wpa.h"
+#endif
 
 
 static int hostapd_flush_old_stations(struct hostapd_data *hapd, u16 reason);
@@ -331,6 +334,9 @@ static void hostapd_free_hapd_data(struc
 	hapd->started = 0;
 
 	wpa_printf(MSG_DEBUG, "%s(%s)", __func__, hapd->conf->iface);
+#ifdef CONFIG_WDS_WPA
+	ltq_wds_wpa_deinit(hapd);
+#endif
 	iapp_deinit(hapd->iapp);
 	hapd->iapp = NULL;
 	accounting_deinit(hapd);
@@ -1184,6 +1190,13 @@ static int hostapd_setup_bss(struct host
 	if (hapd->wpa_auth && wpa_init_keys(hapd->wpa_auth) < 0)
 		return -1;
 
+#ifdef CONFIG_WDS_WPA
+  if (ltq_wds_wpa_init(hapd)) {
+    wpa_printf(MSG_ERROR, "WDS WPA initialization failed");
+    return -1;
+  }
+#endif
+
 	if (hapd->driver && hapd->driver->set_operstate)
 		hapd->driver->set_operstate(hapd->drv_priv, 1);
 
--- a/src/ap/ieee802_1x.c
+++ b/src/ap/ieee802_1x.c
@@ -32,7 +32,9 @@
 #include "wps_hostapd.h"
 #include "hs20.h"
 #include "ieee802_1x.h"
-
+#ifdef CONFIG_WDS_WPA
+#include "rsn_supp/wpa.h"
+#endif
 
 #ifdef CONFIG_HS20
 static void ieee802_1x_wnm_notif_send(void *eloop_ctx, void *timeout_ctx);
@@ -958,6 +960,11 @@ void ieee802_1x_receive(struct hostapd_d
 	    hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&
 	    (key->type == EAPOL_KEY_TYPE_WPA ||
 	     key->type == EAPOL_KEY_TYPE_RSN)) {
+#ifdef CONFIG_WDS_WPA
+	if (sta->wpa)
+	  wpa_sm_rx_eapol(sta->wpa, sa, (u8 *) hdr, sizeof(*hdr) + datalen);
+	else
+#endif
 		wpa_receive(hapd->wpa_auth, sta->wpa_sm, (u8 *) hdr,
 			    sizeof(*hdr) + datalen);
 		return;
--- a/src/common/ltq-vendor.h
+++ b/src/common/ltq-vendor.h
@@ -45,6 +45,7 @@ enum ltq_nl80211_vendor_subcmds {
 	LTQ_NL80211_VENDOR_SUBCMD_GET_VAP_MEASUREMENTS = 12,
 	LTQ_NL80211_VENDOR_SUBCMD_GET_RADIO_INFO       = 13,
 	LTQ_NL80211_VENDOR_SUBCMD_SET_ATF_QUOTAS       = 14,  /* Air time fairness data */
+	LTQ_NL80211_VENDOR_SUBCMD_SET_WDS_WPA_STA      = 15,
 };
 
 enum ltq_nl80211_vendor_events {
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -1542,6 +1542,12 @@ typedef struct mtlk_atf_quotas {
   uint16_t  data[0];    /* Actual layout: u16 vap_grant[nof_bss]; u16 sta_grant[nof_sta]; */
 } __attribute__ ((packed))  mtlk_atf_quotas_t;
 
+
+typedef struct mtlk_mac_addr_list_cfg {
+  u8 addr[ETH_ALEN];
+  u8 remove;
+} mtlk_mac_addr_list_cfg_t;
+
 /**
  * struct wpa_driver_capa - Driver capability information
  */
@@ -4133,6 +4139,16 @@ struct wpa_driver_ops {
 	 */
 	int (*set_default_scan_ies)(void *priv, const u8 *ies, size_t ies_len);
 
+#ifdef CONFIG_WDS_WPA
+  /**
+   * set_deny_mac_addr - Add/remove MAC address to/from WDS WPA station list
+   * @priv: Private driver interface data
+   * @addr: MAC address to use
+   * @remove: 1 - remove address from list, 0 - add address to list
+   * Returns: 0 on success, -1 on failure
+   */
+  int (*set_wds_wpa_sta)(void *priv, const u8 *addr, const u8 remove);
+#endif
 };
 
 /**
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -668,10 +668,13 @@ static int process_beacon_event(struct n
 		os_memset(&event, 0, sizeof(event));
 		event.rx_mgmt.frame = nla_data(tb[NL80211_ATTR_FRAME]);
 		event.rx_mgmt.frame_len = nla_len(tb[NL80211_ATTR_FRAME]);
-		event.rx_mgmt.ssi_signal = (s32) nla_get_u32(tb[NL80211_ATTR_RX_SIGNAL_DBM]);
+    if (!tb[NL80211_ATTR_RX_SIGNAL_DBM]){
+      event.rx_mgmt.ssi_signal = -5000;
+    } else {
+		  event.rx_mgmt.ssi_signal = (s32) nla_get_u32(tb[NL80211_ATTR_RX_SIGNAL_DBM]);
+    }
 		wpa_supplicant_event(drv->ctx, EVENT_RX_MGMT, &event);
 	}
-
 	return NL_SKIP;
 }
 
@@ -9649,6 +9652,29 @@ static int nl80211_get_ext_capab(void *p
 	return 0;
 }
 
+#ifdef CONFIG_WDS_WPA
+int nl80211_set_wds_wpa_sta(void *priv, const u8 *addr, const u8 remove)
+{
+  int ret;
+  mtlk_mac_addr_list_cfg_t wds_wpa_cfg;
+
+  os_memcpy(wds_wpa_cfg.addr, addr, ETH_ALEN);
+  wds_wpa_cfg.remove = remove;
+  ret = nl80211_vendor_cmd(priv, OUI_LTQ,
+    LTQ_NL80211_VENDOR_SUBCMD_SET_WDS_WPA_STA, (u8*) &wds_wpa_cfg,
+    sizeof(wds_wpa_cfg), NULL);
+
+  if (ret < 0)
+    wpa_printf(MSG_ERROR, "nl80211: sending SET_WDS_WPA_STA failed: %i (%s)",
+         ret, strerror(-ret));
+  else
+    wpa_printf(MSG_DEBUG, MACSTR " %s WDS WPA station list", MAC2STR(addr),
+      remove ? "removed from" : "added to");
+
+  return ret;
+}
+#endif
+
 
 const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.name = "nl80211",
@@ -9781,4 +9807,7 @@ const struct wpa_driver_ops wpa_driver_n
 #endif /* CONFIG_DRIVER_NL80211_QCA */
 	.configure_data_frame_filters = nl80211_configure_data_frame_filters,
 	.get_ext_capab = nl80211_get_ext_capab,
+#ifdef CONFIG_WDS_WPA
+	.set_wds_wpa_sta = nl80211_set_wds_wpa_sta,
+#endif
 };
--- a/src/rsn_supp/wpa.c
+++ b/src/rsn_supp/wpa.c
@@ -2285,6 +2285,10 @@ void wpa_sm_deinit(struct wpa_sm *sm)
 	os_free(sm->ap_wpa_ie);
 	os_free(sm->ap_rsn_ie);
 	wpa_sm_drop_sa(sm);
+#ifdef CONFIG_WDS_WPA
+  sm->ctx->cancel_auth_timeout(sm->ctx->ctx);
+  os_free(sm->ctx->ctx);
+#endif
 	os_free(sm->ctx);
 	peerkey_deinit(sm);
 #ifdef CONFIG_IEEE80211R
--- a/src/ap/wpa_auth_ie.c
+++ b/src/ap/wpa_auth_ie.c
@@ -940,3 +940,27 @@ int wpa_auth_uses_mfp(struct wpa_state_m
 {
 	return sm ? sm->mgmt_frame_prot : 0;
 }
+
+
+#ifdef CONFIG_WDS_WPA
+/**
+ * wpa_modify_wpa_ie - Modify RSN IE
+ * @sm: WPA state machine
+   @group_suite: Group Cipher suite
+ * @capab: Capabilities
+ * @size: Size modification of RSN IE
+ * Returns: 0 on success, <0 on failure
+ * Function modifies Group Cipher suite and RSN Capabilities of wpa_ie of WPA
+ * state machine passed in sm with values group_suite and capab passed as
+ * parameters. Modifies size of wpa_ie as well. size parameter is added to
+ * existing size.
+ */
+int wpa_modify_wpa_ie(struct wpa_state_machine *sm, u32 group_suite, u16 capab, int size)
+{
+  if (wpa_modify_wpa_ie_rsn(sm->wpa_ie, sm->wpa_ie_len, group_suite, capab))
+    return -1;
+  sm->wpa_ie[1] += size;
+  sm->wpa_ie_len += size;
+  return 0;
+}
+#endif
--- a/src/common/wpa_common.c
+++ b/src/common/wpa_common.c
@@ -842,6 +842,115 @@ int wpa_parse_wpa_ie_wpa(const u8 *wpa_i
 }
 
 
+#ifdef CONFIG_WDS_WPA
+/**
+ * wpa_modify_wpa_ie_rsn - Modify RSN IE
+ * @rsn_ie: Buffer containing RSN IE
+ * @rsn_ie_len: RSN IE buffer length (including IE number and length octets)
+ * @group_suite: Group Cipher suite
+ * @capab: Capabilities
+ * Returns: 0 on success, <0 on failure
+ * Function modifies Group Cipher suite and RSN Capabilities of RSN IE passed in
+ * rsn_ie with values group_suite and capab passed as parameters.
+ */
+int wpa_modify_wpa_ie_rsn(u8 *rsn_ie, size_t rsn_ie_len, u32 group_suite, u16 capab)
+{
+  u8 *pos;
+  int left;
+  int i, count;
+
+  if (rsn_ie_len == 0) {
+    /* No RSN IE - fail silently */
+    return -1;
+  }
+
+  if (rsn_ie_len < sizeof(struct rsn_ie_hdr)) {
+    wpa_printf(MSG_DEBUG, "%s: ie len too short %lu",
+         __func__, (unsigned long) rsn_ie_len);
+    return -1;
+  }
+
+  if (rsn_ie_len >= 6 && rsn_ie[1] >= 4 &&
+      rsn_ie[1] == rsn_ie_len - 2 &&
+      WPA_GET_BE32(&rsn_ie[2]) == OSEN_IE_VENDOR_TYPE) {
+    pos = rsn_ie + 6;
+    left = rsn_ie_len - 6;
+  } else {
+    const struct rsn_ie_hdr *hdr;
+
+    hdr = (const struct rsn_ie_hdr *) rsn_ie;
+
+    if (hdr->elem_id != WLAN_EID_RSN ||
+        hdr->len != rsn_ie_len - 2 ||
+        WPA_GET_LE16(hdr->version) != RSN_VERSION) {
+      wpa_printf(MSG_DEBUG, "%s: malformed ie or unknown version",
+           __func__);
+      return -2;
+    }
+
+    pos = (u8 *) (hdr + 1);
+    left = rsn_ie_len - sizeof(*hdr);
+  }
+
+  if (left >= RSN_SELECTOR_LEN) {
+    RSN_SELECTOR_PUT(pos, group_suite);
+    pos += RSN_SELECTOR_LEN;
+    left -= RSN_SELECTOR_LEN;
+  } else if (left > 0) {
+    wpa_printf(MSG_DEBUG, "%s: ie length mismatch, %u too much",
+         __func__, left);
+    return -3;
+  }
+
+  if (left >= 2) {
+    count = WPA_GET_LE16(pos);
+    pos += 2;
+    left -= 2;
+    if (count == 0 || count > left / RSN_SELECTOR_LEN) {
+      wpa_printf(MSG_DEBUG, "%s: ie count botch (pairwise), "
+           "count %u left %u", __func__, count, left);
+      return -4;
+    }
+    for (i = 0; i < count; i++) {
+      pos += RSN_SELECTOR_LEN;
+      left -= RSN_SELECTOR_LEN;
+    }
+  } else if (left == 1) {
+    wpa_printf(MSG_DEBUG, "%s: ie too short (for key mgmt)",
+         __func__);
+    return -5;
+  }
+
+  if (left >= 2) {
+    count = WPA_GET_LE16(pos);
+    pos += 2;
+    left -= 2;
+    if (count == 0 || count > left / RSN_SELECTOR_LEN) {
+      wpa_printf(MSG_DEBUG, "%s: ie count botch (key mgmt), "
+           "count %u left %u", __func__, count, left);
+      return -6;
+    }
+    for (i = 0; i < count; i++) {
+      pos += RSN_SELECTOR_LEN;
+      left -= RSN_SELECTOR_LEN;
+    }
+  } else if (left == 1) {
+    wpa_printf(MSG_DEBUG, "%s: ie too short (for capabilities)",
+         __func__);
+    return -7;
+  }
+
+  if (left >= 2) {
+    WPA_PUT_LE16(pos, capab);
+    pos += 2;
+    left -= 2;
+  }
+
+  return 0;
+}
+#endif
+
+
 #ifdef CONFIG_IEEE80211R
 
 /**
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -964,7 +964,9 @@ static int hostapd_mgmt_rx(struct hostap
 	hapd = get_hapd_bssid(iface, bssid);
 	if (hapd == NULL) {
 		u16 fc = le_to_host16(hdr->frame_control);
-
+#ifdef CONFIG_WDS_WPA
+		struct ieee80211_mgmt *mgmt;
+#endif
 		/*
 		 * Drop frames to unknown BSSIDs except for Beacon frames which
 		 * could be used to update neighbor information.
@@ -973,7 +975,28 @@ static int hostapd_mgmt_rx(struct hostap
 		    WLAN_FC_GET_STYPE(fc) == WLAN_FC_STYPE_BEACON)
 			hapd = iface->bss[0];
 		else
-			return 0;
+#ifdef CONFIG_WDS_WPA
+		{
+		  /* set BSSID from destination address */
+      mgmt = (struct ieee80211_mgmt *) rx_mgmt->frame;
+
+      bssid = mgmt->da;
+      hapd = get_hapd_bssid(iface, bssid);
+
+      if ((hapd == NULL) || (hapd == HAPD_BROADCAST)) {
+        return 0;
+      }
+
+      if (!hostapd_maclist_found(hapd->conf->wds_wpa_sta,
+        hapd->conf->num_wds_wpa_sta, mgmt->sa, NULL))
+        return 0;
+
+      /* Replace BSSID for WDS mode */
+      os_memcpy(mgmt->bssid, mgmt->da, ETH_ALEN);
+		}
+#else
+		return 0;
+#endif
 	}
 
 	os_memset(&fi, 0, sizeof(fi));
