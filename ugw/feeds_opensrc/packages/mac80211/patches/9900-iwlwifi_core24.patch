--- a/.local-symbols
+++ b/.local-symbols
@@ -251,12 +251,43 @@ IWLWIFI=
 IWLWIFI_LEDS=
 IWLDVM=
 IWLMVM=
+IWLFMAC=
+IWLTEST=
 IWLWIFI_OPMODE_MODULAR=
+IWLWIFI_PLATFORM_DATA=
 IWLWIFI_BCAST_FILTERING=
-IWLWIFI_PCIE_RTPM=
 IWLWIFI_DEBUG=
 IWLWIFI_DEBUGFS=
 IWLWIFI_DEVICE_TRACING=
+IWLWIFI_DEVICE_TESTMODE=
+IWLWIFI_PCIE=
+IWLWIFI_SDIO=
+IWLXVT=
+IWLWIFI_DBGM=
+IWLWIFI_FRQ_MGR=
+IWLWIFI_FRQ_MGR_TEST=
+IWLWIFI_NUM_CHANNELS=
+IWLWIFI_SUPPORT_DEBUG_OVERRIDES=
+IWLWIFI_THERMAL_DEBUGFS=
+IWLWIFI_FORCE_OFDM_RATE=
+IWLWIFI_BCAST_FILTERING=
+IWLWIFI_SUPPORT_FPGA_BU=
+IWLMVM_TCM=
+IWLWIFI_LTE_COEX=
+IWLMVM_ADVANCED_QUOTA_MGMT=
+IWLMVM_DISABLE_P2P_MIMO=
+IWLWIFI_D0I3_DEFAULT_DISABLE=
+IWLWIFI_PCIE_RTPM=
+IWLMVM_TDLS_PEER_CACHE=
+IWLMVM_P2P_OPPPS_TEST_WA=
+IWLMVM_VENDOR_CMDS=
+IWLMVM_TOF_TSF_WA=
+IWLMVM_WAKELOCK=
+IWLWIFI_DISALLOW_OLDER_FW=
+IWLWIFI_PCIE_FAKE_RXQS=
+IWLWIFI_NUM_STA_INTERFACES=
+IWLWIFI_DISABLE_FW_DUMP=
+IWL_TIMEOUT_FACTOR=
 WLAN_VENDOR_INTERSIL=
 PRISM54=
 HOSTAP=
--- a/backport-include/linux/kernel.h
+++ b/backport-include/linux/kernel.h
@@ -196,6 +196,13 @@ int __must_check kstrtobool_from_user(co
 
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+static inline u32 reciprocal_scale(u32 val, u32 ep_ro)
+{
+	return (u32)(((u64) val * ep_ro) >> 32);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0) */
+
 #endif /* __BACKPORT_KERNEL_H */
 
 /*
--- a/backport-include/net/netlink.h
+++ b/backport-include/net/netlink.h
@@ -42,18 +42,6 @@ static inline int nla_put_s32(struct sk_
 }
 
 /**
- * nla_put_s64 - Add a s64 netlink attribute to a socket buffer
- * @skb: socket buffer to add attribute to
- * @attrtype: attribute type
- * @value: numeric value
- */
-#define nla_put_s64 LINUX_BACKPORT(nla_put_s64)
-static inline int nla_put_s64(struct sk_buff *skb, int attrtype, s64 value)
-{
-	return nla_put(skb, attrtype, sizeof(s64), &value);
-}
-
-/**
  * nla_get_s32 - return payload of s32 attribute
  * @nla: s32 netlink attribute
  */
@@ -189,9 +177,7 @@ static inline __le64 nla_get_le64(const
 }
 #endif /* < 4.4 */
 
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
-
 /**
  * nla_need_padding_for_64bit - test 64-bit alignment of the next attribute
  * @skb: socket buffer the message is stored in
@@ -199,20 +185,20 @@ static inline __le64 nla_get_le64(const
  * Return true if padding is needed to align the next attribute (nla_data()) to
  * a 64-bit aligned area.
  */
+#define nla_need_padding_for_64bit LINUX_BACKPORT(nla_need_padding_for_64bit)
 static inline bool nla_need_padding_for_64bit(struct sk_buff *skb)
 {
 #ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
-	/* The nlattr header is 4 bytes in size, that's why we test
-	 * if the skb->data _is_ aligned.  A NOP attribute, plus
-	 * nlattr header for next attribute, will make nla_data()
-	 * 8-byte aligned.
-	 */
-	if (IS_ALIGNED((unsigned long)skb_tail_pointer(skb), 8))
-		return true;
+       /* The nlattr header is 4 bytes in size, that's why we test
+        * if the skb->data _is_ aligned.  A NOP attribute, plus
+        * nlattr header for next attribute, will make nla_data()
+        * 8-byte aligned.
+        */
+       if (IS_ALIGNED((unsigned long)skb_tail_pointer(skb), 8))
+               return true;
 #endif
-	return false;
+       return false;
 }
-
 /**
  * nla_align_64bit - 64-bit align the nla_data() of next attribute
  * @skb: socket buffer the message is stored in
@@ -221,116 +207,73 @@ static inline bool nla_need_padding_for_
  * Conditionally emit a padding netlink attribute in order to make
  * the next attribute we emit have a 64-bit aligned nla_data() area.
  * This will only be done in architectures which do not have
- * CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS defined.
+ * HAVE_EFFICIENT_UNALIGNED_ACCESS defined.
  *
  * Returns zero on success or a negative error code.
  */
+#define nla_align_64bit LINUX_BACKPORT(nla_align_64bit)
 static inline int nla_align_64bit(struct sk_buff *skb, int padattr)
 {
-	if (nla_need_padding_for_64bit(skb) &&
-	    !nla_reserve(skb, padattr, 0))
-		return -EMSGSIZE;
-
-	return 0;
-}
-
-/**
- * __nla_reserve_64bit - reserve room for attribute on the skb and align it
- * @skb: socket buffer to reserve room on
- * @attrtype: attribute type
- * @attrlen: length of attribute payload
- * @padattr: attribute type for the padding
- *
- * Adds a netlink attribute header to a socket buffer and reserves
- * room for the payload but does not copy it. It also ensure that this
- * attribute will have a 64-bit aligned nla_data() area.
- *
- * The caller is responsible to ensure that the skb provides enough
- * tailroom for the attribute header and payload.
- */
-static inline struct nlattr *__nla_reserve_64bit(struct sk_buff *skb, int attrtype,
-						 int attrlen, int padattr)
-{
-	if (nla_need_padding_for_64bit(skb))
-		nla_align_64bit(skb, padattr);
-
-	return __nla_reserve(skb, attrtype, attrlen);
-}
-
-/**
- * __nla_put_64bit - Add a netlink attribute to a socket buffer and align it
- * @skb: socket buffer to add attribute to
- * @attrtype: attribute type
- * @attrlen: length of attribute payload
- * @data: head of attribute payload
- * @padattr: attribute type for the padding
- *
- * The caller is responsible to ensure that the skb provides enough
- * tailroom for the attribute header and payload.
- */
-static inline void __nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
-				   const void *data, int padattr)
-{
-	struct nlattr *nla;
-
-	nla = __nla_reserve_64bit(skb, attrtype, attrlen, padattr);
-	memcpy(nla_data(nla), data, attrlen);
+       if (nla_need_padding_for_64bit(skb) &&
+            !nla_reserve(skb, padattr, 0))
+                return -EMSGSIZE;
+       return 0;
 }
 
 /**
  * nla_total_size_64bit - total length of attribute including padding
  * @payload: length of payload
  */
+#define nla_total_size_64bit LINUX_BACKPORT(nla_total_size_64bit)
 static inline int nla_total_size_64bit(int payload)
 {
-	return NLA_ALIGN(nla_attr_size(payload))
-#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
-		+ NLA_ALIGN(nla_attr_size(0))
+       return NLA_ALIGN(nla_attr_size(payload))
+#ifndef HAVE_EFFICIENT_UNALIGNED_ACCESS
+               + NLA_ALIGN(nla_attr_size(0))
 #endif
-		;
+               ;
 }
-
+#define __nla_reserve_64bit LINUX_BACKPORT(__nla_reserve_64bit)
+struct nlattr *__nla_reserve_64bit(struct sk_buff *skb, int attrtype,
+				   int attrlen, int padattr);
+#define nla_reserve_64bit LINUX_BACKPORT(nla_reserve_64bit)
+struct nlattr *nla_reserve_64bit(struct sk_buff *skb, int attrtype,
+				 int attrlen, int padattr);
+#define __nla_put_64bit LINUX_BACKPORT(__nla_put_64bit)
+void __nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
+		     const void *data, int padattr);
+#define nla_put_64bit LINUX_BACKPORT(nla_put_64bit)
+int nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
+		  const void *data, int padattr);
 /**
- * nla_put_64bit - Add a netlink attribute to a socket buffer and align it
+ * nla_put_u64_64bit - Add a u64 netlink attribute to a skb and align it
  * @skb: socket buffer to add attribute to
  * @attrtype: attribute type
- * @attrlen: length of attribute payload
- * @data: head of attribute payload
+ * @value: numeric value
  * @padattr: attribute type for the padding
- *
- * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store
- * the attribute header and payload.
  */
-static inline int nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
-				const void *data, int padattr)
+#define nla_put_u64_64bit LINUX_BACKPORT(nla_put_u64_64bit)
+static inline int nla_put_u64_64bit(struct sk_buff *skb, int attrtype,
+                                    u64 value, int padattr)
 {
-	size_t len;
-
-	if (nla_need_padding_for_64bit(skb))
-		len = nla_total_size_64bit(attrlen);
-	else
-		len = nla_total_size(attrlen);
-	if (unlikely(skb_tailroom(skb) < len))
-		return -EMSGSIZE;
-
-	__nla_put_64bit(skb, attrtype, attrlen, data, padattr);
-	return 0;
+        return nla_put_64bit(skb, attrtype, sizeof(u64), &value, padattr);
 }
 
+#define nla_put_u64 DONT_USE_nla_put_u64
+
 /**
- * nla_put_u64_64bit - Add a u64 netlink attribute to a skb and align it
+ * nla_put_s64 - Add a s64 netlink attribute to a socket buffer and align it
  * @skb: socket buffer to add attribute to
  * @attrtype: attribute type
  * @value: numeric value
  * @padattr: attribute type for the padding
  */
-static inline int nla_put_u64_64bit(struct sk_buff *skb, int attrtype,
-				    u64 value, int padattr)
+#define nla_put_s64 LINUX_BACKPORT(nla_put_s64)
+static inline int nla_put_s64(struct sk_buff *skb, int attrtype, s64 value,
+			      int padattr)
 {
-	return nla_put_64bit(skb, attrtype, sizeof(u64), &value, padattr);
+	return nla_put_64bit(skb, attrtype, sizeof(s64), &value, padattr);
 }
-
-
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0) */
+#endif /* < 4.7 */
 
 #endif /* __BACKPORT_NET_NETLINK_H */
--- a/compat/Makefile
+++ b/compat/Makefile
@@ -18,6 +18,7 @@ compat-$(CPTCFG_KERNEL_3_7) += compat-3.
 compat-$(CPTCFG_KERNEL_3_8) += compat-3.8.o
 compat-$(CPTCFG_KERNEL_3_9) += compat-3.9.o
 compat-$(CPTCFG_KERNEL_3_10) += backport-3.10.o
+compat-$(CPTCFG_KERNEL_3_11) += backport-3.11.o
 compat-$(CPTCFG_KERNEL_3_12) += backport-3.12.o
 compat-$(CPTCFG_KERNEL_3_13) += backport-3.13.o
 compat-$(CPTCFG_KERNEL_3_14) += backport-3.14.o
@@ -32,6 +33,7 @@ compat-$(CPTCFG_KERNEL_4_3) += backport-
 compat-$(CPTCFG_KERNEL_4_4) += backport-4.4.o
 compat-$(CPTCFG_KERNEL_4_5) += backport-4.5.o
 compat-$(CPTCFG_KERNEL_4_6) += backport-4.6.o
+compat-$(CPTCFG_KERNEL_4_7) += backport-4.7.o
 
 compat-$(CPTCFG_BPAUTO_BUILD_CRYPTO_CCM) += crypto-ccm.o
 compat-$(CPTCFG_BPAUTO_CRYPTO_SKCIPHER) += crypto-skcipher.o
--- /dev/null
+++ b/compat/backport-3.11.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2016 Intel Deutschland GmbH
+ *
+ * Backport functionality introduced in Linux 3.11.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/scatterlist.h>
+
+static bool sg_miter_get_next_page(struct sg_mapping_iter *miter)
+{
+	if (!miter->__remaining) {
+		struct scatterlist *sg;
+		unsigned long pgoffset;
+
+		if (!__sg_page_iter_next(&miter->piter))
+			return false;
+
+		sg = miter->piter.sg;
+		pgoffset = miter->piter.sg_pgoffset;
+
+		miter->__offset = pgoffset ? 0 : sg->offset;
+		miter->__remaining = sg->offset + sg->length -
+				(pgoffset << PAGE_SHIFT) - miter->__offset;
+		miter->__remaining = min_t(unsigned long, miter->__remaining,
+					   PAGE_SIZE - miter->__offset);
+	}
+
+	return true;
+}
+
+/**
+ * sg_miter_skip - reposition mapping iterator
+ * @miter: sg mapping iter to be skipped
+ * @offset: number of bytes to plus the current location
+ *
+ * Description:
+ *   Sets the offset of @miter to its current location plus @offset bytes.
+ *   If mapping iterator @miter has been proceeded by sg_miter_next(), this
+ *   stops @miter.
+ *
+ * Context:
+ *   Don't care if @miter is stopped, or not proceeded yet.
+ *   Otherwise, preemption disabled if the SG_MITER_ATOMIC is set.
+ *
+ * Returns:
+ *   true if @miter contains the valid mapping.  false if end of sg
+ *   list is reached.
+ */
+static bool sg_miter_skip(struct sg_mapping_iter *miter, off_t offset)
+{
+	sg_miter_stop(miter);
+
+	while (offset) {
+		off_t consumed;
+
+		if (!sg_miter_get_next_page(miter))
+			return false;
+
+		consumed = min_t(off_t, offset, miter->__remaining);
+		miter->__offset += consumed;
+		miter->__remaining -= consumed;
+		offset -= consumed;
+	}
+
+	return true;
+}
+
+/**
+ * sg_copy_buffer - Copy data between a linear buffer and an SG list
+ * @sgl:		 The SG list
+ * @nents:		 Number of SG entries
+ * @buf:		 Where to copy from
+ * @buflen:		 The number of bytes to copy
+ * @skip:		 Number of bytes to skip before copying
+ * @to_buffer:		 transfer direction (true == from an sg list to a
+ *			 buffer, false == from a buffer to an sg list
+ *
+ * Returns the number of copied bytes.
+ *
+ **/
+size_t sg_copy_buffer(struct scatterlist *sgl, unsigned int nents, void *buf,
+		      size_t buflen, off_t skip, bool to_buffer)
+{
+	unsigned int offset = 0;
+	struct sg_mapping_iter miter;
+	unsigned long flags;
+	unsigned int sg_flags = SG_MITER_ATOMIC;
+
+	if (to_buffer)
+		sg_flags |= SG_MITER_FROM_SG;
+	else
+		sg_flags |= SG_MITER_TO_SG;
+
+	sg_miter_start(&miter, sgl, nents, sg_flags);
+
+	if (!sg_miter_skip(&miter, skip))
+		return false;
+
+	local_irq_save(flags);
+
+	while (sg_miter_next(&miter) && offset < buflen) {
+		unsigned int len;
+
+		len = min(miter.length, buflen - offset);
+
+		if (to_buffer)
+			memcpy(buf + offset, miter.addr, len);
+		else
+			memcpy(miter.addr, buf + offset, len);
+
+		offset += len;
+	}
+
+	sg_miter_stop(&miter);
+
+	local_irq_restore(flags);
+	return offset;
+}
+EXPORT_SYMBOL_GPL(sg_copy_buffer);
--- /dev/null
+++ b/compat/backport-4.7.c
@@ -0,0 +1,172 @@
+/*
+ * Copyright(c) 2016 Hauke Mehrtens <hauke-5/S+JYg5SzeELgA04lAiVw@public.gmane.org>
+ *
+ * Backport functionality introduced in Linux 4.7.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+ #include <linux/skbuff.h>
+ #include <net/netlink.h>
+
+ /**
+ * __nla_reserve_64bit - reserve room for attribute on the skb and align it
+ * @skb: socket buffer to reserve room on
+ * @attrtype: attribute type
+ * @attrlen: length of attribute payload
+ *
+ * Adds a netlink attribute header to a socket buffer and reserves
+ * room for the payload but does not copy it. It also ensure that this
+ * attribute will be 64-bit aign.
+ *
+ * The caller is responsible to ensure that the skb provides enough
+ * tailroom for the attribute header and payload.
+ */
+struct nlattr *__nla_reserve_64bit(struct sk_buff *skb, int attrtype,
+                                  int attrlen, int padattr)
+{
+       if (nla_need_padding_for_64bit(skb))
+               nla_align_64bit(skb, padattr);
+
+       return __nla_reserve(skb, attrtype, attrlen);
+}
+EXPORT_SYMBOL_GPL(__nla_reserve_64bit);
+
+ /**
+ * nla_reserve_64bit - reserve room for attribute on the skb and align it
+ * @skb: socket buffer to reserve room on
+ * @attrtype: attribute type
+ * @attrlen: length of attribute payload
+ *
+ * Adds a netlink attribute header to a socket buffer and reserves
+ * room for the payload but does not copy it. It also ensure that this
+ * attribute will be 64-bit aign.
+ *
+ * Returns NULL if the tailroom of the skb is insufficient to store
+ * the attribute header and payload.
+ */
+struct nlattr *nla_reserve_64bit(struct sk_buff *skb, int attrtype, int attrlen,
+				 int padattr)
+{
+       size_t len;
+
+       if (nla_need_padding_for_64bit(skb))
+               len = nla_total_size_64bit(attrlen);
+       else
+               len = nla_total_size(attrlen);
+       if (unlikely(skb_tailroom(skb) < len))
+               return NULL;
+
+       return __nla_reserve_64bit(skb, attrtype, attrlen, padattr);
+}
+EXPORT_SYMBOL_GPL(nla_reserve_64bit);
+
+ /**
+ * __nla_put_64bit - Add a netlink attribute to a socket buffer and align it
+ * @skb: socket buffer to add attribute to
+ * @attrtype: attribute type
+ * @attrlen: length of attribute payload
+ * @data: head of attribute payload
+ *
+ * The caller is responsible to ensure that the skb provides enough
+ * tailroom for the attribute header and payload.
+ */
+void __nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
+                    const void *data, int padattr)
+{
+       struct nlattr *nla;
+
+       nla = __nla_reserve_64bit(skb, attrtype, attrlen, padattr);
+       memcpy(nla_data(nla), data, attrlen);
+}
+EXPORT_SYMBOL_GPL(__nla_put_64bit);
+
+ /**
+ * nla_put_64bit - Add a netlink attribute to a socket buffer and align it
+ * @skb: socket buffer to add attribute to
+ * @attrtype: attribute type
+ * @attrtype: attribute type
+ * @attrlen: length of attribute payload
+ * @data: head of attribute payload
+ *
+ * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store
+ * the attribute header and payload.
+ */
+int nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
+                 const void *data, int padattr)
+{
+       size_t len;
+
+       if (nla_need_padding_for_64bit(skb))
+               len = nla_total_size_64bit(attrlen);
+       else
+               len = nla_total_size(attrlen);
+       if (unlikely(skb_tailroom(skb) < len))
+               return -EMSGSIZE;
+
+       __nla_put_64bit(skb, attrtype, attrlen, data, padattr);
+       return 0;
+}
+EXPORT_SYMBOL_GPL(nla_put_64bit);
+
+#if defined(CPTCFG_BPAUTO_WANT_DEV_COREDUMP) && !defined(CPTCFG_BPAUTO_BUILD_WANT_DEV_COREDUMP)
+#include <linux/devcoredump.h>
+
+static void devcd_free_sgtable(void *data)
+{
+	struct scatterlist *table = data;
+	int i;
+	struct page *page;
+	struct scatterlist *iter;
+	struct scatterlist *delete_iter;
+
+	/* free pages */
+	iter = table;
+	for_each_sg(table, iter, sg_nents(table), i) {
+		page = sg_page(iter);
+		if (page)
+			__free_page(page);
+	}
+
+	/* then free all chained tables */
+	iter = table;
+	delete_iter = table;	/* always points on a head of a table */
+	while (!sg_is_last(iter)) {
+		iter++;
+		if (sg_is_chain(iter)) {
+			iter = sg_chain_ptr(iter);
+			kfree(delete_iter);
+			delete_iter = iter;
+		}
+	}
+
+	/* free the last table */
+	kfree(delete_iter);
+}
+
+static ssize_t devcd_read_from_sgtable(char *buffer, loff_t offset,
+				       size_t buf_len, void *data,
+				       size_t data_len)
+{
+	struct scatterlist *table = data;
+
+	if (offset > data_len)
+		return -EINVAL;
+
+	if (offset + buf_len > data_len)
+		buf_len = data_len - offset;
+	return sg_pcopy_to_buffer(table, sg_nents(table), buffer, buf_len,
+				  offset);
+}
+
+void dev_coredumpsg(struct device *dev, struct scatterlist *table,
+		    size_t datalen, gfp_t gfp)
+{
+	dev_coredumpm(dev, THIS_MODULE, table, datalen, gfp,
+		      devcd_read_from_sgtable,
+		      devcd_free_sgtable);
+}
+EXPORT_SYMBOL_GPL(dev_coredumpsg);
+#endif /* CPTCFG_BPAUTO_WANT_DEV_COREDUMP && !CPTCFG_BPAUTO_BUILD_WANT_DEV_COREDUMP */
--- a/drivers/net/wireless/intel/iwlwifi/iwl-tm-gnl.c
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-tm-gnl.c
@@ -431,15 +431,16 @@ static int iwl_tm_gnl_get_build_info(str
 	resp = (struct iwl_tm_build_info *)data_out->data;
 
 	memset(resp, 0 , sizeof(*resp));
-	strncpy(resp->driver_version, BACKPORTS_GIT_TRACKED,
+	strncpy(resp->driver_version, CPTCFG_VERSION,
 		sizeof(resp->driver_version));
+/*
 #ifdef BACKPORTS_BRANCH_TSTAMP
 	strncpy(resp->branch_time, BACKPORTS_BRANCH_TSTAMP,
 		sizeof(resp->branch_time));
 #endif
 	strncpy(resp->build_time, BACKPORTS_BUILD_TSTAMP,
 		sizeof(resp->build_time));
-
+*/
 	return 0;
 }
 
--- a/drivers/net/wireless/intel/iwlwifi/mvm/testmode.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/testmode.c
@@ -233,7 +233,7 @@ static int iwl_tm_get_dev_info(struct iw
 			       struct iwl_tm_data *data_out)
 {
 	struct iwl_tm_dev_info *dev_info;
-	const u8 driver_ver[] = BACKPORTS_GIT_TRACKED;
+	const u8 driver_ver[] = CPTCFG_VERSION;
 
 	dev_info = kzalloc(sizeof(struct iwl_tm_dev_info) +
 			   (strlen(driver_ver)+1)*sizeof(u8), GFP_KERNEL);
--- a/drivers/net/wireless/intel/iwlwifi/xvt/user-infc.c
+++ b/drivers/net/wireless/intel/iwlwifi/xvt/user-infc.c
@@ -355,7 +355,7 @@ static int iwl_xvt_get_dev_info(struct i
 {
 	struct iwl_tm_dev_info_req *dev_info_req;
 	struct iwl_tm_dev_info *dev_info;
-	const u8 driver_ver[] = BACKPORTS_GIT_TRACKED;
+	const u8 driver_ver[] = CPTCFG_VERSION;
 	int sv_step = 0x00;
 	int dev_info_size;
 	bool read_sv_drop = true;
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -1632,6 +1632,8 @@ struct ieee80211_vht_operation {
 #define IEEE80211_SPCT_MSR_RPRT_TYPE_BASIC	0
 #define IEEE80211_SPCT_MSR_RPRT_TYPE_CCA	1
 #define IEEE80211_SPCT_MSR_RPRT_TYPE_RPI	2
+#define IEEE80211_SPCT_MSR_RPRT_TYPE_LCI	8
+#define IEEE80211_SPCT_MSR_RPRT_TYPE_CIVIC	11
 
 /* 802.11g ERP information element */
 #define WLAN_ERP_NON_ERP_PRESENT (1<<0)
@@ -2324,8 +2326,12 @@ enum ieee80211_sa_query_action {
 #define WLAN_AKM_SUITE_FT_OVER_SAE	0x000FAC09
 
 #define WLAN_MAX_KEY_LEN		32
+#define WLAN_PSK_LEN			32
 
 #define WLAN_PMKID_LEN			16
+#define WLAN_PMK_LEN_EAP_LEAP		16
+#define WLAN_PMK_LEN			32
+#define WLAN_PMK_LEN_SUITE_B_192	48
 
 #define WLAN_OUI_WFA			0x506f9a
 #define WLAN_OUI_TYPE_WFA_P2P		9
@@ -2371,6 +2377,85 @@ struct ieee80211_tspec_ie {
 	__le16 medium_time;
 } __packed;
 
+enum ieee80211_ftm_status_indication {
+	IEEE80211_FTM_STATUS_IND_RESERVED = 0,
+	IEEE80211_FTM_STATUS_IND_SUCCESS,
+	IEEE80211_FTM_STATUS_IND_INCAPABLE,
+	IEEE80211_FTM_STATUS_IND_FAILED,
+};
+
+enum ieee80211_ftm_burst_duration {
+	IEEE80211_FTM_BURST_DUR_250_USEC = 2,
+	IEEE80211_FTM_BURST_DUR_500_USEC = 3,
+	IEEE80211_FTM_BURST_DUR_1_MSEC   = 4,
+	IEEE80211_FTM_BURST_DUR_2_MSEC   = 5,
+	IEEE80211_FTM_BURST_DUR_4_MSEC   = 6,
+	IEEE80211_FTM_BURST_DUR_8_MSEC   = 7,
+	IEEE80211_FTM_BURST_DUR_16_MSEC  = 8,
+	IEEE80211_FTM_BURST_DUR_32_MSEC  = 9,
+	IEEE80211_FTM_BURST_DUR_64_MSEC  = 10,
+	IEEE80211_FTM_BURST_DUR_128_MSEC = 11,
+	IEEE80211_FTM_BURST_DUR_NO_PREF  = 15,
+};
+
+enum ieee80211_ftm_format_and_bw {
+	IEEE80211_FTM_FORMAT_BW_NO_PREF           = 0,
+	IEEE80211_FTM_FORMAT_BW_NON_HT_5          = 4,
+	IEEE80211_FTM_FORMAT_BW_NON_HT_10         = 6,
+	IEEE80211_FTM_FORMAT_BW_NON_HT_20         = 8,
+	IEEE80211_FTM_FORMAT_BW_HT_20             = 9,
+	IEEE80211_FTM_FORMAT_BW_VHT_20            = 10,
+	IEEE80211_FTM_FORMAT_BW_HT_40             = 11,
+	IEEE80211_FTM_FORMAT_BW_VHT_40            = 12,
+	IEEE80211_FTM_FORMAT_BW_VHT_80            = 13,
+	IEEE80211_FTM_FORMAT_BW_VHT_80_80         = 14,
+	IEEE80211_FTM_FORMAT_BW_VHT_TWO_RF_LO_160 = 15,
+	IEEE80211_FTM_FORMAT_BW_VHT_ONE_RF_LO_160 = 16,
+	IEEE80211_FTM_FORMAT_BW_DMG_2160          = 31,
+};
+
+/**
+ * struct ieee80211_ftm_params_ie - IEEE802.11 spec definition
+ *
+ * struct defined according to spec's Figure 8-569 - "Fine Timing
+ * Measurement Parameters element format", and Figure 8-570 - "Fine Timing
+ * Measurement Parameters field format"
+ * Note: Spec refers to Draft 802.11REVmc_D4.3 (Oct. 2015)
+ */
+struct ieee80211_ftm_params_ie {
+	u8 element_id;
+	u8 len;
+	u8 status_info;
+	u8 burst_info;
+	u8 min_delta_ftm;
+	__le16 partial_tsf_timer;
+	u8 data1;
+	u8 data2;
+	__le16 burst_period;
+} __packed;
+
+#define IEEE80211_FTM_PARAMS_STATUS_IND_MASK 0x03
+#define IEEE80211_FTM_PARAMS_STATUS_IND_SHIFT 0
+#define IEEE80211_FTM_PARAMS_STATUS_VALUE_MASK 0x7C
+#define IEEE80211_FTM_PARAMS_STATUS_VALUE_SHIFT 2
+
+#define IEEE80211_FTM_PARAMS_BURST_EXPONENT_MASK 0x0F
+#define IEEE80211_FTM_PARAMS_BURST_EXPONENT_SHIFT 0
+#define IEEE80211_FTM_PARAMS_BURST_DURATION_MASK 0xF0
+#define IEEE80211_FTM_PARAMS_BURST_DURATION_SHIFT 4
+
+#define IEEE80211_FTM_PARAMS_DATA1_PARTIAL_TSF_TIMER_NP_MASK 0x01
+#define IEEE80211_FTM_PARAMS_DATA1_PARTIAL_TSF_TIMER_NP_SHIFT 0
+#define IEEE80211_FTM_PARAMS_DATA1_ASAP_CAPABLE_MASK 0x02
+#define IEEE80211_FTM_PARAMS_DATA1_ASAP_CAPABLE_SHIFT 1
+#define IEEE80211_FTM_PARAMS_DATA1_ASAP_MASK 0x04
+#define IEEE80211_FTM_PARAMS_DATA1_ASAP_SHIFT 2
+#define IEEE80211_FTM_PARAMS_DATA1_FTMS_PER_BURST_MASK 0xF8
+#define IEEE80211_FTM_PARAMS_DATA1_FTMS_PER_BURST_SHIFT 3
+
+#define IEEE80211_FTM_PARAMS_DATA2_FORMAT_AND_BW_MASK 0xFC
+#define IEEE80211_FTM_PARAMS_DATA2_FORMAT_AND_BW_SHIFT 2
+
 /**
  * ieee80211_get_qos_ctl - get pointer to qos control bytes
  * @hdr: the frame
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -631,6 +631,7 @@ struct survey_info {
  *	allowed through even on unauthorized ports
  * @control_port_no_encrypt: TRUE to prevent encryption of control port
  *	protocol frames.
+ * @psk: PSK (for devices supporting 4Way-handshake offload)
  * @wep_keys: static WEP keys, if not NULL points to an array of
  *	CFG80211_MAX_WEP_KEYS WEP keys
  * @wep_tx_key: key index (0..3) of the default TX static WEP key
@@ -645,6 +646,7 @@ struct cfg80211_crypto_settings {
 	bool control_port;
 	__be16 control_port_ethertype;
 	bool control_port_no_encrypt;
+	const u8 *psk;
 	struct key_params *wep_keys;
 	int wep_tx_key;
 };
@@ -2131,11 +2133,15 @@ enum wiphy_params_flags {
  * caching.
  *
  * @bssid: The AP's BSSID.
- * @pmkid: The PMK material itself.
+ * @pmkid: The PMK identifier.
+ * @pmk: The PMK material itself.
+ * @pmk_len: The PMK length in bytes.
  */
 struct cfg80211_pmksa {
 	const u8 *bssid;
 	const u8 *pmkid;
+	const u8 *pmk;
+	u8 pmk_len;
 };
 
 /**
@@ -2405,6 +2411,255 @@ struct cfg80211_qos_map {
 };
 
 /**
+ * struct cfg80211_ftm_target - data for an FTM target (FTM responder)
+ *
+ * @cookie: Extra data for the use of the invoking component. This will be
+ *	passed back to the caller in the response, along with the rest of the
+ *	request.
+ * @chan_def: target's channel info
+ * @bssid: target's BSSID.
+ * @one_sided: whether to perform a one-sided (flag set) or two-sided (flag
+ *	clear) measurement.
+ * @asap: Whether to perform the measurement in ASAP mode. Ignored if one-sided.
+ * @lci: Whether to query for LCI in the request. Ignored if one-sided.
+ * @civic: Whether to query for CIVIC in the request. Ignored if one-sided.
+ * @num_of_bursts_exp: exponent of 2 of the number of measurement iterations.
+ * @burst_period: Measurement periodicity in units of 100ms.
+ *	Ignored if num_of_bursts_exp is 0.
+ * @samples_per_burst: Number of measurement frames requested per burst.
+ * @retries: Number of retries per sample.
+ * @burst_duration: duration of an rtt burst. Valid values are 2-11 and 15
+ * @ftm_preamble: Allowed preamble types to be used for FTM frames.
+ *	Bitfield, as specified in @enum nl80211_ftm_preamble.
+ * @ftm_bw: Allowed bandwidths to be used for FTM frames.
+ *	Bitfield, as specified in @enum nl80211_ftm_bw.
+ */
+struct cfg80211_ftm_target {
+	u64 cookie;
+	struct cfg80211_chan_def chan_def;
+	u8 bssid[ETH_ALEN];
+	bool one_sided;
+	bool asap;
+	bool lci;
+	bool civic;
+	u8 num_of_bursts_exp;
+	u16 burst_period;
+	u8 samples_per_burst;
+	u8 retries;
+	u8 burst_duration;
+	u8 ftm_preamble;
+	u8 ftm_bw;
+};
+
+/**
+ * struct cfg80211_ftm_request - data for FTM requests
+ *
+ * @report_tsf: if true, report the TSF of the AP to which the vif is
+ *	associated. Not relevant if the vif is not associated.
+ * @timeout: Timespan within which measurement should complete. Given in units
+ *	of 100ms.
+ * @macaddr_template: Sets the fixed part of a randomized mac address.
+ * @macaddr_mask: Bits set to 1 shall be copied from @macaddr_template. Bits set
+ *	to 0 shall be randomized by the device.
+ * @num_of_targets: Number of targets (with which to perform a measurement)
+ *	contained in this request (see @targets). &num_of_target will not
+ *	exceed the value reported for the device in
+ *	%NL80211_ATTR_MAX_TOTAL_FTM_TARGETS.
+ * @targets: List of targets with which to perform the measurement. This list is
+ *	dynamically allocated when the request arrives, and should be released
+ *	using kfree by the underlying driver when it is no longer required.
+ *	Amongst these targets, the number of 2-sided requests will not exceed
+ *	the value reported for the device in
+ *	%NL80211_ATTR_MAX_TWO_SIDED_FTM_TARGETS.
+ */
+struct cfg80211_ftm_request {
+	bool report_tsf;
+	u8 timeout;
+	u8 macaddr_template[ETH_ALEN];
+	u8 macaddr_mask[ETH_ALEN];
+	u8 num_of_targets;
+	struct cfg80211_ftm_target *targets;
+};
+
+/**
+ * struct cfg80211_msrment_request - measurement request data
+ *
+ * @type: Type of measurement. Determines the actual type of the union field
+ *	below.
+ * @nl_portid: the netlink port used for this request
+ * @u: Data for the specific required measurement type.
+ */
+struct cfg80211_msrment_request {
+	enum nl80211_msrment_type type;
+	u32 nl_portid;
+	union {
+		struct cfg80211_ftm_request ftm;
+	} u;
+};
+
+/**
+ * struct cfg80211_ftm_result - data for an FTM result of a single target
+ *
+ * @filled: bitmap using the bits of &enum nl80211_ftm_response_entry to
+ *	indicate which field is relevant in this struct.
+ * @status: Status of measurement
+ * @complete: Whether this measurement is the last one expected for this target.
+ *	This implies that resources associated with this target may be released.
+ * @target: Pointer to the corresponding FTM target given in the request.
+ * @host_time: Time in which:
+ *	- in case of error - error was detected
+ *	- in case of success - successful measurement started
+ *	Given value is in nanoseconds elapsed since host boot time
+ *	(referring to CLOCK_BOOTTIME).
+ *	Note that this reported value is an estimation of the actual event time,
+ *	with expected error of up to 20ms off the actual mark. Underlying
+ *	devices must make sure they comply with this limited tolerance.
+ * @tsf: Same as %host_time, but in the expressed as the TSF of the AP the vif
+ *	is associated to. This value is not an estimation. If field
+ *	&report_tsf in the request is not set, this field is ignored.
+ * @burst_index: Ordinal number of currently reported measurement iteration.
+ * @measurement_num: Total FTM measurement frames attempted
+ * @success_num: Total successful FTM measurement frames
+ * @num_per_burst: Maximum number of FTM frames per burst supported by the
+ *	responder. Applies to 2-sided FTM only.
+ * @retry_after_duration: When status == NL80211_FTM_RESP_TARGET_BUSY, the
+ *	initiator may retry after this given time. In sec
+ * @burst_duration: Actual time taken by the FW to finish one burst. In usec.
+ * @negotiated_burst_num: Number of bursts allowed by the responder. Applies
+ *	to 2-sided FTM only
+ * @rssi: Measured RSSI, given in dBm. Valid values range: -128-0.
+ * @rssi_spread: The difference between max and min measured RSSI values
+ * @tx_rate_info: Used tx rate-related data.
+ * @rx_rate_info: Used rx rate-related data.
+ * @rtt: The Round Trip Time that took for the last measurement for current
+ *	target, in psec. Since a measurement can have an error tolerance, this
+ *	value can be negative.
+ * @rtt_variance: The variance of the RTT values measured for current target, in
+ *	psec^2.
+ * @rtt_spread: The difference between max and min RTT values measured for
+ *	the current target in the current session, in psec.
+ * @distance: distance from target, in cm.  Since a measurement can have an
+ *	error tolerance, this value can be negative.
+ * @distance_variance: variance of the distance, in cm^2.
+ * @distance_spread: The difference between max and min distance values measured
+ *	for the current target in the current session, in cm.
+ * @lci_len: length of the LCI buffer.
+ * @lci: the LCI info buffer.
+ * @civic_len: length of the CIVIC buffer.
+ * @civic: the CIVIC info buffer.
+ */
+struct cfg80211_ftm_result {
+	u32 filled;
+	enum nl80211_ftm_response_status status;
+	bool complete;
+	struct cfg80211_ftm_target *target;
+	u64 host_time;
+	u64 tsf;
+	u8 burst_index;
+	u32 measurement_num;
+	u32 success_num;
+	u8 num_per_burst;
+	u8 retry_after_duration;
+	u32 burst_duration;
+	u32 negotiated_burst_num;
+	s8 rssi;
+	u8 rssi_spread;
+	struct rate_info tx_rate_info;
+	struct rate_info rx_rate_info;
+	s64 rtt;
+	u64 rtt_variance;
+	u64 rtt_spread;
+	s64 distance;
+	u64 distance_variance;
+	u64 distance_spread;
+	u32 lci_len;
+	const u8 *lci;
+	u32 civic_len;
+	const u8 *civic;
+};
+
+/**
+ * struct cfg80211_ftm_results - data for FTM results of all targets
+ *
+ * @num_of_entries: num of entries in the results array
+ * @entries: an array of FTM results. this array is both allocated and
+ *	released in the driver.
+ */
+struct cfg80211_ftm_results {
+	u8 num_of_entries;
+	struct cfg80211_ftm_result *entries;
+};
+
+/**
+ * struct cfg80211_msrment_response - measurement response data
+ * @cookie: Identifier of current measurement response, matching the one given
+ *	in the request.
+ * @type: Type of measurement. Determines the actual type of the union field
+ *	below.
+ * @status: Status of current measurement response.
+ * @nl_portid: netlink port this response should be sent to
+ * @u: Data for the specific reported measurement type.
+ */
+struct cfg80211_msrment_response {
+	u64 cookie;
+	enum nl80211_msrment_type type;
+	enum nl80211_msrment_status status;
+	u32 nl_portid;
+	union {
+		struct cfg80211_ftm_results ftm;
+	} u;
+};
+
+/**
+ * cfg80211_ftm_responder_params - FTM responder parameters
+ *
+ * @lci: LCI subelemnt content
+ * @civic: CIVIC subelemnt content
+ * @lci_len: LCI data len
+ * @civic_len: CIVIC data len
+ */
+struct cfg80211_ftm_responder_params {
+	const u8 *lci;
+	const u8 *civic;
+	size_t lci_len;
+	size_t civic_len;
+};
+
+/**
+ * cfg80211_ftm_responder_stats - FTM responder statistics
+ *
+ * @filled: bitflag of flags using the bits of &enum nl80211_ftm_stats to
+ *	indicate the relevant values in this struct for them
+ * @success_num: number of FTM sessions in which all frames were successfully
+ *	answered
+ * @partial_num: number of FTM sessions in which part of frames were
+ *	successfully answered
+ * @failed_num: number of failed FTM sessions
+ * @asap_num: number of ASAP FTM sessions
+ * @non_asap_num: number of  non-ASAP FTM sessions
+ * @total_duration_ms: total sessions durations - gives an indication
+ *	of how much time the responder was busy
+ * @unknown_triggers_num: number of unknown FTM triggers - triggers from
+ *	initiators that didn't finish successfully the negotiation phase with
+ *	the responder
+ * @reschedule_requests_num: number of FTM reschedule requests - initiator asks
+ *	for a new scheduling although it already has scheduled FTM slot
+ * @out_of_window_triggers_num: total FTM triggers out of scheduled window
+ */
+struct cfg80211_ftm_responder_stats {
+	u32 filled;
+	u32 success_num;
+	u32 partial_num;
+	u32 failed_num;
+	u32 asap_num;
+	u32 non_asap_num;
+	u64 total_duration_ms;
+	u32 unknown_triggers_num;
+	u32 reschedule_requests_num;
+	u32 out_of_window_triggers_num;
+};
+
+/**
  * struct cfg80211_nan_conf - NAN configuration
  *
  * This struct defines NAN configuration parameters
@@ -2627,9 +2882,10 @@ struct cfg80211_nan_func {
  *	cases, the result of roaming is indicated with a call to
  *	cfg80211_roamed() or cfg80211_roamed_bss().
  *	(invoked with the wireless_dev mutex held)
- * @disconnect: Disconnect from the BSS/ESS. Once done, call
- *	cfg80211_disconnected().
- *	(invoked with the wireless_dev mutex held)
+ * @disconnect: Disconnect from the BSS/ESS or stop connection attempts if
+ *      connection is in progress. Once done, call cfg80211_disconnected() in
+ *      case connection was already established (invoked with the
+ *      wireless_dev mutex held), otherwise call cfg80211_connect_timeout().
  *
  * @join_ibss: Join the specified IBSS (or create if necessary). Once done, call
  *	cfg80211_ibss_joined(), also call that function when changing BSSID due
@@ -2785,6 +3041,14 @@ struct cfg80211_nan_func {
  *	and returning to the base channel for communication with the AP.
  * @tdls_cancel_channel_switch: Stop channel-switching with a TDLS peer. Both
  *	peers must be on the base channel when the call completes.
+ *
+ * @perform_msrment: Perform a measurement according to the given request. Once
+ *	this function returns, the given request pointer in no longer valid.
+ *	The cookie must be filled to a unique value for this request, for later
+ *	possible aborting.
+ * @abort_msrment: Abort a previously requested measurement.
+ *
+ * @start_ftm_responder: Start and configure FTM responder.
  * @start_nan: Start the NAN interface.
  * @stop_nan: Stop the NAN interface.
  * @add_nan_func: Add a NAN function. Returns negative value on failure.
@@ -3064,6 +3328,18 @@ struct cfg80211_ops {
 	void	(*tdls_cancel_channel_switch)(struct wiphy *wiphy,
 					      struct net_device *dev,
 					      const u8 *addr);
+	int	(*perform_msrment)(struct wiphy *wiphy,
+				   struct wireless_dev *wdev,
+				   struct cfg80211_msrment_request *request,
+				   u64 *cookie);
+	int	(*abort_msrment)(struct wiphy *wiphy, struct wireless_dev *wdev,
+				 u64 cookie);
+	int	(*start_ftm_responder)(struct wiphy *wiphy,
+				       struct net_device *dev,
+				struct cfg80211_ftm_responder_params *params);
+	int	(*get_ftm_responder_stats)(struct wiphy *wiphy,
+					   struct net_device *dev,
+				struct cfg80211_ftm_responder_stats *ftm_stats);
 	int	(*start_nan)(struct wiphy *wiphy, struct wireless_dev *wdev,
 			     struct cfg80211_nan_conf *conf);
 	void	(*stop_nan)(struct wiphy *wiphy, struct wireless_dev *wdev);
@@ -3149,6 +3425,7 @@ enum wiphy_flags {
 	WIPHY_FLAG_SUPPORTS_5_10_MHZ		= BIT(22),
 	WIPHY_FLAG_HAS_CHANNEL_SWITCH		= BIT(23),
 	WIPHY_FLAG_HAS_STATIC_WEP		= BIT(24),
+	WIPHY_FLAG_HAS_FTM_RESPONDER		= BIT(25),
 };
 
 /**
@@ -3356,6 +3633,36 @@ struct wiphy_vendor_command {
 };
 
 /**
+ * struct wiphy_ftm_initiator_capa - wiphy FTM initiator capabilities
+ *
+ * @max_two_sided_ftm_targets: Max number of 2-sided targets allowed by the
+ *	device in an FTM request.
+ * @max_total_ftm_targets: Max number of targets (both 1-sided and 2-sided)
+ *	allowed by the device in an FTM request.
+ * @asap: true if ASAP is supported.
+ * @non_asap: true if non-ASAP is supported.
+ * @req_tsf: true if user can request to report the associated AP's TSF.
+ *	see %NL80211_FTM_REQ_ATTR_REPORT_TSF.
+ * @req_lci: true if reporting target's LCI is supported.
+ * @req_civic: true if reporting target's CIVIC is supported.
+ * @preamble: bitmap of supported preambles for FTM frames. Values are defined
+ *	in &enum nl80211_ftm_preamble.
+ * @bw: bitmap of supported bandwidths for FTM frames. Values are defined in
+ *	&enum nl80211_ftm_bw.
+ */
+struct wiphy_ftm_initiator_capa {
+	u32 max_two_sided_ftm_targets;
+	u32 max_total_ftm_targets;
+	bool asap;
+	bool non_asap;
+	bool req_tsf;
+	bool req_lci;
+	bool req_civic;
+	u32 preamble;
+	u32 bw;
+};
+
+/**
  * struct wiphy_iftype_ext_capab - extended capabilities per interface type
  * @iftype: interface type
  * @extended_capabilities: extended capabilities supported by the driver,
@@ -3528,6 +3835,8 @@ struct wiphy_iftype_ext_capab {
  *	attribute indices defined in &enum nl80211_bss_select_attr.
  *
  * @cookie_counter: unique generic cookie counter, used to identify objects.
+ * @ftm_initiator_capa: FTM initiator capabilities. If NULL, ftm initiator is
+ *	not supported.
  */
 struct wiphy {
 	/* assign these fields before you register the wiphy */
@@ -3662,6 +3971,8 @@ struct wiphy {
 
 	u64 cookie_counter;
 
+	const struct wiphy_ftm_initiator_capa *ftm_initiator_capa;
+
 	char priv[0] __aligned(NETDEV_ALIGN);
 };
 
@@ -4136,14 +4447,29 @@ unsigned int ieee80211_get_mesh_hdrlen(s
  */
 
 /**
+ * ieee80211_data_to_8023_exthdr - convert an 802.11 data frame to 802.3
+ * @skb: the 802.11 data frame
+ * @ehdr: pointer to a &struct ethhdr that will get the header, instead
+ *	of it being pushed into the SKB
+ * @addr: the device MAC address
+ * @iftype: the virtual interface type
+ * Return: 0 on success. Non-zero on error.
+ */
+int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,
+				  const u8 *addr, enum nl80211_iftype iftype);
+
+/**
  * ieee80211_data_to_8023 - convert an 802.11 data frame to 802.3
  * @skb: the 802.11 data frame
  * @addr: the device MAC address
  * @iftype: the virtual interface type
  * Return: 0 on success. Non-zero on error.
  */
-int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
-			   enum nl80211_iftype iftype);
+static inline int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
+					 enum nl80211_iftype iftype)
+{
+	return ieee80211_data_to_8023_exthdr(skb, NULL, addr, iftype);
+}
 
 /**
  * ieee80211_data_from_8023 - convert an 802.3 frame to 802.11
@@ -4161,22 +4487,23 @@ int ieee80211_data_from_8023(struct sk_b
 /**
  * ieee80211_amsdu_to_8023s - decode an IEEE 802.11n A-MSDU frame
  *
- * Decode an IEEE 802.11n A-MSDU frame and convert it to a list of
- * 802.3 frames. The @list will be empty if the decode fails. The
- * @skb is consumed after the function returns.
+ * Decode an IEEE 802.11 A-MSDU and convert it to a list of 802.3 frames.
+ * The @list will be empty if the decode fails. The @skb must be fully
+ * header-less before being passed in here; it is freed in this function.
  *
- * @skb: The input IEEE 802.11n A-MSDU frame.
+ * @skb: The input A-MSDU frame without any headers.
  * @list: The output list of 802.3 frames. It must be allocated and
  *	initialized by by the caller.
  * @addr: The device MAC address.
  * @iftype: The device interface type.
  * @extra_headroom: The hardware extra headroom for SKBs in the @list.
- * @has_80211_header: Set it true if SKB is with IEEE 802.11 header.
+ * @check_da: DA to check in the inner ethernet header, or NULL
+ * @check_sa: SA to check in the inner ethernet header, or NULL
  */
 void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
 			      const u8 *addr, enum nl80211_iftype iftype,
 			      const unsigned int extra_headroom,
-			      bool has_80211_header);
+			      const u8 *check_da, const u8 *check_sa);
 
 /**
  * cfg80211_classify8021d - determine the 802.1p/1d tag for a data frame
@@ -4635,7 +4962,8 @@ void cfg80211_auth_timeout(struct net_de
  *	moves to cfg80211 in this call
  * @buf: authentication frame (header + body)
  * @len: length of the frame data
- * @uapsd_queues: bitmap of ACs configured to uapsd. -1 if n/a.
+ * @uapsd_queues: bitmap of queues configured for uapsd. Same format
+ *	as the AC bitmap in the QoS info field
  *
  * After being asked to associate via cfg80211_ops::assoc() the driver must
  * call either this function or cfg80211_auth_timeout().
@@ -5668,6 +5996,17 @@ void cfg80211_crit_proto_stopped(struct
 unsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy);
 
 /**
+ * cfg80211_measurement_response - notify regarding a measurement response
+ *
+ * @wiphy: the wiphy
+ * @response: a response for which to notify
+ * @gfp: allocation flags
+ */
+void cfg80211_measurement_response(struct wiphy *wiphy,
+				   struct cfg80211_msrment_response *response,
+				   gfp_t gfp);
+
+/**
  * cfg80211_check_combinations - check interface combinations
  *
  * @wiphy: the wiphy
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -1421,6 +1421,9 @@ enum ieee80211_vif_flags {
  *	these need to be set (or cleared) when the interface is added
  *	or, if supported by the driver, the interface type is changed
  *	at runtime, mac80211 will never touch this field
+ * @filter_gratuitous_arp_unscol_na: User space configuration if to filter
+ *	gratuitous arp & unsolicited na packets
+ * @filter_gtk: User space configuration if to filter gtk packets
  * @hw_queue: hardware queue for each AC
  * @cab_queue: content-after-beacon (DTIM beacon really) queue, AP mode only
  * @chanctx_conf: The channel context this interface is assigned to, or %NULL
@@ -1454,6 +1457,11 @@ struct ieee80211_vif {
 
 	u32 driver_flags;
 
+#ifdef CPTCFG_IWLMVM_VENDOR_CMDS
+	bool filter_grat_arp_unsol_na;
+	bool filter_gtk;
+#endif
+
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	struct dentry *debugfs_dir;
 #endif
@@ -1747,7 +1755,8 @@ struct ieee80211_sta_rates {
  * @drv_priv: data area for driver use, will always be aligned to
  *	sizeof(void *), size is determined in hw information.
  * @uapsd_queues: bitmap of queues configured for uapsd. Only valid
- *	if wme is supported.
+ *	if wme is supported. The bits order is like in
+ *	IEEE80211_WMM_IE_STA_QOSINFO_AC_*.
  * @max_sp: max Service Period. Only valid if wme is supported.
  * @bandwidth: current bandwidth the station can receive with
  * @rx_nss: in HT/VHT, the maximum number of spatial streams the
@@ -2027,8 +2036,9 @@ struct ieee80211_txq {
  *	drivers, mac80211 packet loss mechanism will not be triggered and driver
  *	is completely depending on firmware event for station kickout.
  *
- * @IEEE80211_HW_NEEDS_ALIGNED4_SKBS: Driver need aligned skbs to four-byte.
- *	Padding will be added after ieee80211_hdr, before IV/LLC.
+ * @IEEE80211_HW_SUPPORTS_TX_FRAG: Hardware does fragmentation by itself.
+ *	The stack will not do fragmentation.
+ *	The callback for @set_frag_threshold should be set as well.
  *
  * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays
  */
@@ -2072,11 +2082,33 @@ enum ieee80211_hw_flags {
 	IEEE80211_HW_TX_FRAG_LIST,
 	IEEE80211_HW_REPORTS_LOW_ACK,
 	IEEE80211_HW_NEEDS_ALIGNED4_SKBS,
+	IEEE80211_HW_SUPPORTS_TX_FRAG,
 
 	/* keep last, obviously */
 	NUM_IEEE80211_HW_FLAGS
 };
 
+/*
+ * struct ieee80211_tx_thrshld_md - tx packet metadata that crosses a thrshld
+ *
+ * @mode: recording mode (Internal buffer or continues recording)
+ * @monitor_collec_wind: the size of the window to collect the logs
+ * @seq: packet sequence
+ * @pkt_start: start time of triggering pkt
+ * @pkt_end: end time of triggering pkt
+ * @msrmnt: the tx latency of the pkt
+ * @tid: tid of the pkt
+ */
+struct ieee80211_tx_thrshld_md {
+	u8 mode;
+	u16 monitor_collec_wind;
+	u16 seq;
+	u32 pkt_start;
+	u32 pkt_end;
+	u32 msrmnt;
+	u16 tid;
+};
+
 /**
  * struct ieee80211_hw - hardware information and state
  *
@@ -3099,8 +3131,9 @@ enum ieee80211_reconfig_type {
  *	The callback must be atomic.
  *
  * @set_frag_threshold: Configuration of fragmentation threshold. Assign this
- *	if the device does fragmentation by itself; if this callback is
- *	implemented then the stack will not do fragmentation.
+ *	if the device does fragmentation by itself. Note that to prevent the
+ *	stack from doing fragmentation IEEE80211_HW_SUPPORTS_TX_FRAG
+ *	should be set as well.
  *	The callback can sleep.
  *
  * @set_rts_threshold: Configuration of RTS threshold (if device needs it)
@@ -3438,6 +3471,12 @@ enum ieee80211_reconfig_type {
  *	pending frames that were received prior to the control path action
  *	currently taken (e.g. disassociation) but are not processed yet.
  *
+ * @perform_ftm: Perform a Fine Timing Measurement with the given request
+ *	parameters. The given request can only be used within the function call.
+ * @abort_ftm: Abort a Fine Timing Measurement request. The given cookie must
+ *	match that of the active FTM request.
+ * @start_ftm_responder: Start FTM responder and configure its parameters.
+ *
  * @start_nan: join an existing NAN cluster, or create a new one.
  * @stop_nan: leave the NAN cluster.
  * @nan_change_conf: change NAN configuration. The data in cfg80211_nan_conf
@@ -3690,6 +3729,17 @@ struct ieee80211_ops {
 			      struct ieee80211_txq *txq);
 	void (*sync_rx_queues)(struct ieee80211_hw *hw);
 
+	int (*perform_ftm)(struct ieee80211_hw *hw, u64 cookie,
+			   struct ieee80211_vif *vif,
+			   struct cfg80211_ftm_request *ftm_req);
+	int (*abort_ftm)(struct ieee80211_hw *hw, u64 cookie);
+	int (*start_ftm_responder)(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   struct cfg80211_ftm_responder_params *params);
+	int (*get_ftm_responder_stats)(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				struct cfg80211_ftm_responder_stats *ftm_stats);
+
 	int (*start_nan)(struct ieee80211_hw *hw,
 			 struct ieee80211_vif *vif,
 			 struct cfg80211_nan_conf *conf);
@@ -4093,6 +4143,10 @@ void ieee80211_sta_pspoll(struct ieee802
  * This must be used in conjunction with ieee80211_sta_ps_transition()
  * and possibly ieee80211_sta_pspoll(); calls to all three must be
  * serialized.
+ * %IEEE80211_NUM_TIDS can be passed as the tid if the tid is unknown.
+ * In this case, mac80211 will not check that this tid maps to an AC
+ * that is trigger enabled and assume that the caller did the proper
+ * checks.
  */
 void ieee80211_sta_uapsd_trigger(struct ieee80211_sta *sta, u8 tid);
 
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -67,6 +67,8 @@ enum environment_cap {
  *	CRDA and can be used by other regulatory requests. When a
  *	the last request is not yet processed we must yield until it
  *	is processed before processing any new requests.
+ * @is_indoor: indicates if the device is operating in an indoor environment
+ *      or not
  * @country_ie_checksum: checksum of the last processed and accepted
  *	country IE
  * @country_ie_env: lets us know if the AP is telling us we are outdoor,
@@ -82,6 +84,7 @@ struct regulatory_request {
 	enum nl80211_dfs_regions dfs_region;
 	bool intersect;
 	bool processed;
+	bool is_indoor;
 	enum environment_cap country_ie_env;
 	struct list_head list;
 };
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -10,7 +10,7 @@
  * Copyright 2008, 2009 Luis R. Rodriguez <lrodriguez@atheros.com>
  * Copyright 2008 Jouni Malinen <jouni.malinen@atheros.com>
  * Copyright 2008 Colin McCabe <colin@cozybit.com>
- * Copyright 2015	Intel Deutschland GmbH
+ * Copyright 2015-2016	Intel Deutschland GmbH
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -371,7 +371,8 @@
  *	NL80211_CMD_GET_SURVEY and on the "scan" multicast group)
  *
  * @NL80211_CMD_SET_PMKSA: Add a PMKSA cache entry, using %NL80211_ATTR_MAC
- *	(for the BSSID) and %NL80211_ATTR_PMKID.
+ *	(for the BSSID) and %NL80211_ATTR_PMKID. Optionally, %NL80211_ATTR_PMK
+ *	can be used to specify the PMK.
  * @NL80211_CMD_DEL_PMKSA: Delete a PMKSA cache entry, using %NL80211_ATTR_MAC
  *	(for the BSSID) and %NL80211_ATTR_PMKID.
  * @NL80211_CMD_FLUSH_PMKSA: Flush all PMKSA cache entries.
@@ -874,6 +875,27 @@
  *	This will contain a %NL80211_ATTR_NAN_MATCH nested attribute and
  *	%NL80211_ATTR_COOKIE.
  *
+ * @NL80211_CMD_MSRMENT_REQUEST: Request to perform some type of measurement.
+ *	Request type is given by %NL80211_ATTR_MSRMENT_TYPE. Additional data is
+ *	given according to the request type.
+ *	When called, this operation returns a cookie (%NL80211_ATTR_COOKIE)
+ *	that will be included with any events pertaining to this request.
+ *	In order to abort the request, the socket which sent the request needs
+ *	to be closed. It is strongly recommended that each request will have a
+ *	separate socket.
+ * @NL80211_CMD_MSRMENT_RESPONSE: Reports measurement results in response to a
+ *	previous measurement request. A cookie matching the previous request is
+ *	given by %NL80211_ATTR_COOKIE. Response type is given by
+ *	%NL80211_ATTR_MSRMENT_TYPE. Response status is given by
+ *	%NL80211_ATTR_MSRMENT_STATUS. Additional data is given according to the
+ *	request type.
+ *	This message might be sent multiple times for one response, splitting
+ *	the response into several segments. The @NL80211_ATTR_LAST_MSG flag
+ *	should be set in the last message of the response.
+ * @NL80211_CMD_START_FTM_RESPONDER: Start FTM responder and set its parameters.
+ *	This is supported only on AP interface. FTM responder cannot be stopped
+ *	without removing the interface.
+ *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -1069,6 +1091,12 @@ enum nl80211_commands {
 	NL80211_CMD_CHANGE_NAN_CONFIG,
 	NL80211_CMD_NAN_MATCH,
 
+	NL80211_CMD_MSRMENT_REQUEST,
+	NL80211_CMD_MSRMENT_RESPONSE,
+
+	NL80211_CMD_START_FTM_RESPONDER,
+	NL80211_CMD_GET_FTM_RESPONDER_STATS,
+
 	/* add new commands above here */
 
 	/* used to define NL80211_CMD_MAX below */
@@ -1740,7 +1768,9 @@ enum nl80211_commands {
  *
  * @NL80211_ATTR_OPMODE_NOTIF: Operating mode field from Operating Mode
  *	Notification Element based on association request when used with
- *	%NL80211_CMD_NEW_STATION; u8 attribute.
+ *	%NL80211_CMD_NEW_STATION or %NL80211_CMD_SET_STATION (only when
+ *	%NL80211_FEATURE_FULL_AP_CLIENT_STATE is supported, or with TDLS);
+ *	u8 attribute.
  *
  * @NL80211_ATTR_VENDOR_ID: The vendor ID, either a 24-bit OUI or, if
  *	%NL80211_VENDOR_ID_IS_LINUX is set, a special Linux ID (not used yet)
@@ -1941,6 +1971,31 @@ enum nl80211_commands {
  *
  * @NL80211_ATTR_WIPHY_ANTENNA_GAIN: Configured antenna gain. Used to reduce
  *	transmit power to stay within regulatory limits. u32, dBi.
+ * @NL80211_ATTR_MSRMENT_TYPE: Type of current measurement request/response.
+ *	(values defined in &enum nl80211_msrment_type).
+ * @NL80211_ATTR_MSRMENT_STATUS: Status of current measurement response.
+ *	(values defined in &enum nl80211_msrment_status)
+ * @NL80211_ATTR_MSRMENT_FTM_REQUEST: Container for data of an FTM measurement
+ *	request (nested. see &enum nl80211_ftm_request)
+ * @NL80211_ATTR_MSRMENT_FTM_RESPONSE: An AP with which a measurement was
+ *	attempted (nested. see &enum nl80211_ftm_response_entry)
+ *	An FTM response consists of series of such messages, where the last
+ *	message is marked with the @NL80211_ATTR_LAST_MSG flag.
+ * @NL80211_ATTR_MSRMENT_FTM_CAPA: FTM initiator capabilities. see
+ *	&enum nl80211_ftm_initiator_capa. Not in use in case FTM is not
+ *	supported. nested.
+ * @NL80211_ATTR_LAST_MSG: Indicates that this message is the last one in the
+ *	series of messages. (flag)
+ *
+ * @NL80211_ATTR_LCI: The content of measurement report IE (Section 8.4.2.21 in
+ *	spec) with type 8 - LCI (Section 8.4.2.21.10)
+ * @NL80211_ATTR_CIVIC: The content of measurement Report IE (Section 8.4.2.21
+ *	in spec) with type 11 - Civic (Section 8.4.2.21.13)
+ *
+ * @NL80211_ATTR_PMK: PMK for offloaded 4-Way Handshake. Relevant with
+ *	%NL80211_CMD_CONNECT (for WPA/WPA2-PSK networks) when PSK is used, or
+ *	with %NL80211_CMD_SET_PMKSA when 802.1X authentication is used and for
+ *	PMKSA caching.
  *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
@@ -2337,13 +2392,28 @@ enum nl80211_attrs {
 	NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY,
 
 	NL80211_ATTR_MESH_PEER_AID,
+	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
 
 	NL80211_ATTR_NAN_MASTER_PREF,
 	NL80211_ATTR_NAN_DUAL,
 	NL80211_ATTR_NAN_FUNC,
 	NL80211_ATTR_NAN_MATCH,
 
-	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
+	NL80211_ATTR_FTM_RESPONDER_STATS,
+
+	NL80211_ATTR_MSRMENT_TYPE,
+	NL80211_ATTR_MSRMENT_STATUS,
+
+	NL80211_ATTR_MSRMENT_FTM_REQUEST,
+	NL80211_ATTR_MSRMENT_FTM_RESPONSE,
+	NL80211_ATTR_MSRMENT_FTM_CAPA,
+
+	NL80211_ATTR_LAST_MSG,
+
+	NL80211_ATTR_LCI,
+	NL80211_ATTR_CIVIC,
+
+	NL80211_ATTR_PMK,
 
 	/* add attributes here, update the policy in nl80211.c */
 
@@ -4645,6 +4715,9 @@ enum nl80211_feature_flags {
  *	configuration (AP/mesh) with HT rates.
  * @NL80211_EXT_FEATURE_BEACON_RATE_VHT: Driver supports beacon rate
  *	configuration (AP/mesh) with VHT rates.
+ * @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_OFFLOAD_STA: Device supports
+ *	doing 4-way handshake in station mode (PSK is passed as part
+ *	of the connect command).
  *
  * @NUM_NL80211_EXT_FEATURES: number of extended features.
  * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
@@ -4659,6 +4732,7 @@ enum nl80211_ext_feature_index {
 	NL80211_EXT_FEATURE_BEACON_RATE_LEGACY,
 	NL80211_EXT_FEATURE_BEACON_RATE_HT,
 	NL80211_EXT_FEATURE_BEACON_RATE_VHT,
+	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_OFFLOAD_STA,
 
 	/* add new features before the definition below */
 	NUM_NL80211_EXT_FEATURES,
@@ -5134,4 +5208,417 @@ enum nl80211_nan_match_attributes {
 	NL80211_NAN_MATCH_ATTR_MAX = NUM_NL80211_NAN_MATCH_ATTR - 1
 };
 
+/*
+ * enum nl80211_msrment_type - measurement types
+ *
+ * Used to indicate the requested/reported measurement type in
+ * %NL80211_CMD_MSRMENT_REQUEST or %NL80211_CMD_MSRMENT_RESPONSE.
+ *
+ * @NL80211_MSRMENT_TYPE_FTM: Fine Timing Measurement.
+ *	An FTM request should be constructed according to &enum
+ *	nl80211_ftm_request.
+ *	An FTM response is a serie of messages, each meassage including a
+ *	single FTM target, described in &enum nl80211_ftm_target. The last
+ *	message in the serie is marked with the @NL80211_ATTR_LAST_MSG flag.
+ *	Status @NL80211_MSRMENT_STATUS_REFUSED is used if the device is not
+ *	available for FTM operations. Status @NL80211_MSRMENT_STATUS_FAIL is
+ *	used if the device attempted to perform the measurements, but all failed
+ *	for local reasons. In these both cases, no response is included in the
+ *	message. In other cases @NL80211_MSRMENT_STATUS_SUCCESS is used.
+ *	In the latter case, internal status of each target is used to
+ *	indicate the measurement status of each particular target.
+ */
+enum nl80211_msrment_type {
+	NL80211_MSRMENT_TYPE_FTM,
+};
+
+/**
+ * enum nl80211_msrment_status - measurement response status values
+ *
+ * @NL80211_MSRMENT_STATUS_SUCCESS: Measurement performed. This does not mean
+ *	every sub-measurement was successful, but only that as a whole, the
+ *	operation succeeded. More detailed status should reside in the internal
+ *	parts of the response, and according to the measurement type.
+ * @NL80211_MSRMENT_STATUS_REFUSED: Device is refusing to perform the required
+ *	measurement. Note that not every measurement can be performed at every
+ *	given moment in time. See specific measurement details for execution
+ *	conditions.
+ * @NL80211_MSRMENT_STATUS_TIMEOUT: Timeout given in
+ *	@NL80211_FTM_REQ_ATTR_TIMEOUT has expired before request completion.
+ *	The response will include completed measurements.
+ * @NL80211_MSRMENT_STATUS_FAIL: Measurement failed.
+ */
+enum nl80211_msrment_status {
+	NL80211_MSRMENT_STATUS_SUCCESS,
+	NL80211_MSRMENT_STATUS_REFUSED,
+	NL80211_MSRMENT_STATUS_TIMEOUT,
+	NL80211_MSRMENT_STATUS_FAIL,
+};
+
+/**
+ * enum nl80211_ftm_preamble - Allowed preamble types to use in FTM frames
+ *
+ * @NL80211_FTM_PREAMBLE_LEGACY: Legacy preamble
+ * @NL80211_FTM_PREAMBLE_HT: HT preamble
+ * @NL80211_FTM_PREAMBLE_VHT: VHT preamble
+ */
+enum nl80211_ftm_preamble {
+	NL80211_FTM_PREAMBLE_LEGACY = 1 << 0,
+	NL80211_FTM_PREAMBLE_HT     = 1 << 1,
+	NL80211_FTM_PREAMBLE_VHT    = 1 << 2
+};
+
+/**
+ * enum nl80211_ftm_bw - Allowed bandwidths to use in FTM frames
+ *
+ * @NL80211_FTM_BW_5: 5Mhz
+ * @NL80211_FTM_BW_10: 10Mhz
+ * @NL80211_FTM_BW_20: 20Mhz
+ * @NL80211_FTM_BW_40: 40Mhz
+ * @NL80211_FTM_BW_80: 80Mhz
+ * @NL80211_FTM_BW_160: 160Mhz
+ */
+enum nl80211_ftm_bw {
+	NL80211_FTM_BW_5   = 1 << 0,
+	NL80211_FTM_BW_10  = 1 << 1,
+	NL80211_FTM_BW_20  = 1 << 2,
+	NL80211_FTM_BW_40  = 1 << 3,
+	NL80211_FTM_BW_80  = 1 << 4,
+	NL80211_FTM_BW_160 = 1 << 5
+};
+
+/**
+ * enum nl80211_ftm_initiator_capa - FTM initiator capabilities
+ *
+ * @NL80211_FTM_CAPA_MAX_2_SIDED: Max number of 2-sided targets allowed by the
+ *	device in an FTM request. (u32)
+ * @NL80211_FTM_CAPA_MAX_TOTAL: Max number of targets (both 1-sided and 2-sided)
+ *	allowed by the device in an FTM request. (u32)
+ * @NL80211_FTM_CAPA_ASAP: Set if ASAP is supported. (flag)
+ * @NL80211_FTM_CAPA_NON_ASAP: Set if non-ASAP is supported. (flag)
+ * @NL80211_FTM_CAPA_REQ_TSF: Set if user can request to report the associated
+ *	AP's TSF. see %NL80211_FTM_REQ_ATTR_REPORT_TSF. (flag)
+ * @NL80211_FTM_CAPA_REQ_LCI: Set if reporting target's LCI is supported. (flag)
+ * @NL80211_FTM_CAPA_REQ_CIVIC: Set if reporting target's CIVIC is supported.
+ *	(flag)
+ * @NL80211_FTM_CAPA_PREAMBLE: supported preambles for FTM frames. bitmap of
+ *	&enum nl80211_ftm_preamble. (u32)
+ * @NL80211_FTM_CAPA_BW: supported bandwidths for FTM frames. bitmap of
+ *	enum nl80211_ftm_bw. (u32)
+ */
+enum nl80211_ftm_initiator_capa {
+	__NL80211_FTM_CAPA_INVALID,
+	NL80211_FTM_CAPA_MAX_2_SIDED,
+	NL80211_FTM_CAPA_MAX_TOTAL,
+	NL80211_FTM_CAPA_ASAP,
+	NL80211_FTM_CAPA_NON_ASAP,
+	NL80211_FTM_CAPA_REQ_TSF,
+	NL80211_FTM_CAPA_REQ_LCI,
+	NL80211_FTM_CAPA_REQ_CIVIC,
+	NL80211_FTM_CAPA_PREAMBLE,
+	NL80211_FTM_CAPA_BW,
+
+	/* keep last */
+	__NL80211_FTM_CAPA_AFTER_LAST,
+	NL80211_FTM_CAPA_MAX = __NL80211_FTM_CAPA_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_ftm_target - attributes for an FTM target
+ *
+ * An FTM target is a station with which to perform measurements.
+ *
+ * @__NL80211_FTM_TARGET_ATTR_INVALID: invalid
+ * @NL80211_FTM_TARGET_ATTR_FREQ: Target's frequency (u32)
+ * @NL80211_FTM_TARGET_ATTR_BW: Target's actual channel bandwidth. Only BWs
+ *	supported by the device are allowed. (u8, one of
+ *	&enum nl80211_chan_width)
+ * @NL80211_FTM_TARGET_ATTR_CNTR_FREQ_1: Center freq., 1st segment, if relevant
+ *	(u32)
+ * @NL80211_FTM_TARGET_ATTR_CNTR_FREQ_2: Center freq., 2nd segment, if relevant
+ *	(u32)
+ * @NL80211_FTM_TARGET_ATTR_BSSID: Target's BSSID (6 octets)
+ * @NL80211_FTM_TARGET_ATTR_ONE_SIDED: whether to perform a one-sided (flag set)
+ *	or two-sided (flag clear) measurement. (flag)
+ * @NL80211_FTM_TARGET_ATTR_NUM_OF_BURSTS_EXP: Exponent of 2 of the number of
+ *	measurement iterations. Optional (default: 0). (u8)
+ * @NL80211_FTM_TARGET_ATTR_BURST_PERIOD: Measurement periodicity in units of
+ *	100ms. Ignored if num of bursts exp is 0. (u16)
+ * @NL80211_FTM_TARGET_ATTR_SAMPLES_PER_BURST: Number of measurement frames
+ *	requested per burst. Optional (default: 2) (u8)
+ * @NL80211_FTM_TARGET_ATTR_RETRIES: Number of retries per sample.
+ *	Optional (default: 3). (u8)
+ * @NL80211_FTM_TARGET_ATTR_BURST_DURATION: duration of an rtt burst.
+ *	Valid values are 2-11 and 15. Optional (default: 15) (u8)
+ * @NL80211_FTM_TARGET_ATTR_ASAP: Whether to perform the measurement in ASAP
+ *	mode. Ignored if one-sided. Request will be refused if:
+ *	ASAP requested and %NL80211_FTM_CAPA_ASAP isn't set by the device, or
+ *	non-ASAP requested and %NL80211_FTM_CAPA_NON_ASAP isn't set by the
+ *	device. (flag)
+ * @NL80211_FTM_TARGET_QUERY_LCI: Whether to include an LCI query in the
+ *	request. Request will be refused if %NL80211_FTM_CAPA_REQ_LCI isn't set
+ *	by the device. (flag)
+ * @NL80211_FTM_TARGET_QUERY_CIVIC: Whether to include a CIVIC query in the
+ *	request. Request will be refused if %NL80211_FTM_CAPA_REQ_CIVIC isn't
+ *	set by the device. (flag)
+ * @NL80211_FTM_TARGET_ATTR_COOKIE: Extra data for the use of the invoking
+ *	component. This will be passed back to the caller in the response, along
+ *	with the rest of the request. Optional. (u64)
+ * @NL80211_FTM_TARGET_ATTR_FTM_PREAMBLE: Allowed preamble types to be used for
+ *	FTM frames. Bitfield, as specified in @enum nl80211_ftm_preamble.
+ *	Request will be refused if the supplied bitfield isn't supported in
+ *	%NL80211_FTM_CAPA_PREAMBLE. (u8)
+ * @NL80211_FTM_TARGET_ATTR_FTM_BW: Allowed bandwidths to be used for FTM
+ *	frames. Bitfield, as specified in @enum nl80211_ftm_bw. Request will be
+ *	refused if the supplied bitfield isn't supported in
+ *	%NL80211_FTM_CAPA_BW. (u8)
+ * @NL80211_FTM_TARGET_ATTR_PAD: used for padding, ignore
+ * @__NL80211_FTM_TARGET_ATTR_AFTER_LAST: internal
+ * @NL80211_FTM_TARGET_ATTR_MAX: highest FTM target attribute
+ */
+enum nl80211_ftm_target {
+	__NL80211_FTM_TARGET_ATTR_INVALID,
+	NL80211_FTM_TARGET_ATTR_FREQ,
+	NL80211_FTM_TARGET_ATTR_BW,
+	NL80211_FTM_TARGET_ATTR_CNTR_FREQ_1,
+	NL80211_FTM_TARGET_ATTR_CNTR_FREQ_2,
+	NL80211_FTM_TARGET_ATTR_BSSID,
+	NL80211_FTM_TARGET_ATTR_ONE_SIDED,
+	NL80211_FTM_TARGET_ATTR_NUM_OF_BURSTS_EXP,
+	NL80211_FTM_TARGET_ATTR_BURST_PERIOD,
+	NL80211_FTM_TARGET_ATTR_SAMPLES_PER_BURST,
+	NL80211_FTM_TARGET_ATTR_RETRIES,
+	NL80211_FTM_TARGET_ATTR_BURST_DURATION,
+	NL80211_FTM_TARGET_ATTR_ASAP,
+	NL80211_FTM_TARGET_ATTR_QUERY_LCI,
+	NL80211_FTM_TARGET_ATTR_QUERY_CIVIC,
+	NL80211_FTM_TARGET_ATTR_COOKIE,
+	NL80211_FTM_TARGET_ATTR_FTM_PREAMBLE,
+	NL80211_FTM_TARGET_ATTR_FTM_BW,
+	NL80211_FTM_TARGET_ATTR_PAD,
+
+	/* keep last */
+	__NL80211_FTM_TARGET_ATTR_AFTER_LAST,
+	NL80211_FTM_TARGET_ATTR_MAX = __NL80211_FTM_TARGET_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_ftm_request - attributes for an FTM request
+ *
+ * Note: Only a single FTM request can be handled at a time.
+ *
+ * @__NL80211_FTM_REQ_ATTR_INVALID: invalid
+ * @NL80211_FTM_REQ_ATTR_TIMEOUT: Timespan within which measurement should
+ *	complete. Given in tenths of a second. Optional (default: 50). (u8)
+ * @NL80211_FTM_REQ_ATTR_MACADDR_TEMPLATE: Device will use the given template
+ *	(and mask, see ahead) to generate a mac address for identification. This
+ *	attribute sets the fixed part of a randomized mac address. (6 octets)
+ *	The MC bit must be set to 0.
+ * @NL80211_FTM_REQ_ATTR_MACADDR_MASK: Mask for mac address randomization. Bits
+ *	set to 1 shall be copied from %NL80211_FTM_REQ_ATTR_MACADDR_TEMPLATE.
+ *	Bits set to 0 shall be randomized by the device.
+ *	MC bit should not be randomized(set to 1). (6 octets)
+ * @NL80211_FTM_REQ_ATTR_REPORT_TSF: Flag that indicates to use the associated
+ *	AP's TSF in the %NL80211_FTM_RESP_ENTRY_ATTR_TSF field in the response.
+ *	Useful for RRM requests, where an associated AP requires to perform FTM,
+ *	and expects a timestamp in its own TSF. If not set, no tsf value is
+ *	reported in the response. Ignored if no AP is associated.
+ *	Request will be refused if %NL80211_FTM_CAPA_REQ_TSF is not set. (flag)
+ * @NL80211_FTM_REQ_ATTR_TARGETS: List of targets with which to perform
+ *	measurements. Length shall not exceed the value reported for the device
+ *	in %NL80211_FTM_CAPA_MAX_TOTAL. Among these targets, the number
+ *	of 2-sided requests shall not exceed the value reported for the device
+ *	in %NL80211_FTM_CAPA_MAX_2_SIDED.
+ *	(nested. see &enum nl80211_ftm_target)
+ *
+ * @__NL80211_FTM_REQ_ATTR_AFTER_LAST: internal
+ * @NL80211_FTM_REQ_ATTR_MAX: highest FTM request attribute
+ */
+enum nl80211_ftm_request {
+	__NL80211_FTM_REQ_ATTR_INVALID,
+	NL80211_FTM_REQ_ATTR_TIMEOUT,
+	NL80211_FTM_REQ_ATTR_MACADDR_TEMPLATE,
+	NL80211_FTM_REQ_ATTR_MACADDR_MASK,
+	NL80211_FTM_REQ_ATTR_REPORT_TSF,
+	NL80211_FTM_REQ_ATTR_TARGETS,
+
+	/* keep last */
+	__NL80211_FTM_REQ_ATTR_AFTER_LAST,
+	NL80211_FTM_REQ_ATTR_MAX = __NL80211_FTM_REQ_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_ftm_response_status - status of an FTM measurement attempt
+ *
+ * @NL80211_FTM_RESP_SUCCESS: Successful measurement, given results are valid.
+ * @NL80211_FTM_RESP_TARGET_INCAPAB: Target reported incapable
+ * @NL80211_FTM_RESP_TARGET_BUSY: Target reported busy
+ * @NL80211_FTM_RESP_NOT_MEASURED: Target not measured due to timeout expiration
+ * @NL80211_FTM_RESP_TARGET_UNAVAILABLE: Target is unavailable.
+ * @NL80211_FTM_RESP_FAIL: Failed for some other reason.
+ */
+enum nl80211_ftm_response_status {
+	NL80211_FTM_RESP_SUCCESS,
+	NL80211_FTM_RESP_TARGET_INCAPAB,
+	NL80211_FTM_RESP_TARGET_BUSY,
+	NL80211_FTM_RESP_NOT_MEASURED,
+	NL80211_FTM_RESP_TARGET_UNAVAILABLE,
+	NL80211_FTM_RESP_FAIL,
+};
+
+/**
+ * enum nl80211_ftm_response_entry - attributes for an FTM response entry
+ *
+ * An FTM response entry represents a single target with which an FTM
+ *	measurement was attempted.
+ *
+ * @__NL80211_FTM_RESP_ENTRY_ATTR_INVALID: invalid
+ * @NL80211_FTM_RESP_ENTRY_ATTR_STATUS: Status of measurement. (u8, one of
+ *	&enum nl80211_ftm_response_status)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_COMPLETE: Whether this measurement is the last
+ *	one expected for this target. This implies that resources associated
+ *	with this target may be released. (flag)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_TARGET: The corresponding FTM target entry in
+ *	the measurement request. (nested. see &enum nl80211_ftm_target)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_HOST_TIME: Time, given in nanoseconds since
+ *	host boot time(referring to CLOCK_BOOTTIME), in which:
+ *	- in case of error - error was detected
+ *	- in case of success - successful measurement started
+ *	Note that this reported value is an estimation of the actual event time,
+ *	with expected error of up to 20ms off the actual mark. Underlying
+ *	devices must make sure they comply with this limited tolerance.
+ *	Optional. (u64)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_TSF: Same as %NL80211_FTM_RESP_ATTR_HOST_TIME,
+ *	but the value is TSF of the associated AP. Optional - present only if
+ *	%NL80211_FTM_REQ_ATTR_AP_REPORT_TSF was set in the request, and an
+ *	associated AP exists. Also, this value is not an estimation.
+ *	Optional.(u64)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_BURST_INDEX: Ordinal number of currently
+ *	reported measurement iteration. Optional.(u8)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_MSRMNT_NUM: Total FTM measurement frames
+ *	attempted. Optional.(u32)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_SUCCESS_NUM: Total successful FTM measurement
+ *	frames. Optional.(u32)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_NUM_PER_BURST: Maximum number of FTM frames per
+ *	burst supported by the responder. Applies to 2-sided FTM only.
+ *	Optional.(u8)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_RETRY_DUR: When
+ *	status == NL80211_FTM_RESP_TARGET_BUSY, the initiator may retry after
+ *	this given time. In sec. Optional.(u8)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_BURST_DUR: Actual time taken by the FW to finish
+ *	one burst. In usec. Optional.(u32)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_NEG_BURST_NUM: Number of bursts allowed by the
+ *	responder. Applies to 2-sided FTM only. Optional.(u32)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_RSSI: Measured RSSI, given in dBm. Valid values
+ *	range: -128-0. Optional.(s8)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_RSSI_SPREAD: The difference between max and min
+ *	measured RSSI values. Optional.(u8)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_TX_RATE_INFO: tx Rate-related data. (nested. see
+ *	enum nl80211_rate_info). Optional.
+ * @NL80211_FTM_RESP_ENTRY_ATTR_RX_RATE_INFO: rx Rate-related data. (nested. see
+ *	enum nl80211_rate_info). Optional.
+ * @NL80211_FTM_RESP_ENTRY_ATTR_RTT: The Round Trip Time that took for the last
+ *	measurement for current target, in psec. Since a measurement can have an
+ *	error tolerance, it can be negative. (s64)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_RTT_VAR: The variance of the RTT values measured
+ *	for current target, in psec^2. Optional.(u64)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_RTT_SPREAD: The difference between max and min
+ *	RTT values measured for the current target in the current session, given
+ *	in psec. Optional.(u64)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_DISTANCE: distance from target, in cm. Since a
+ *	measurement can have an error tolerance, it can be negative. Optional.
+ *	(s64)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_DISTANCE_VAR: variance of the distance, in cm^2.
+ *	Optional. (u64)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_DISTANCE_SPREAD: The difference between max and
+ *	min distance values measured for the current target in the current
+ *	session, in cm. Optional. (u64)
+ * @NL80211_FTM_RESP_ENTRY_ATTR_LCI: the LCI data buffer of the target. Will be
+ *	provided only if available and %NL80211_FTM_TARGET_QUERY_LCI was set in
+ *	the request.
+ * @NL80211_FTM_RESP_ENTRY_ATTR_CIVIC: the CIVIC data buffer of the target. Will
+ *	be provided only if available and %NL80211_FTM_TARGET_QUERY_CIVIC was
+ *	set in the request.
+ * @NL80211_FTM_RESP_ENTRY_ATTR_PAD: used for padding, ignore
+ */
+enum nl80211_ftm_response_entry {
+	__NL80211_FTM_RESP_ENTRY_ATTR_INVALID,
+	NL80211_FTM_RESP_ENTRY_ATTR_STATUS,
+	NL80211_FTM_RESP_ENTRY_ATTR_COMPLETE,
+	NL80211_FTM_RESP_ENTRY_ATTR_TARGET,
+	NL80211_FTM_RESP_ENTRY_ATTR_HOST_TIME,
+	NL80211_FTM_RESP_ENTRY_ATTR_TSF,
+	NL80211_FTM_RESP_ENTRY_ATTR_BURST_INDEX,
+	NL80211_FTM_RESP_ENTRY_ATTR_MSRMNT_NUM,
+	NL80211_FTM_RESP_ENTRY_ATTR_SUCCESS_NUM,
+	NL80211_FTM_RESP_ENTRY_ATTR_NUM_PER_BURST,
+	NL80211_FTM_RESP_ENTRY_ATTR_RETRY_DUR,
+	NL80211_FTM_RESP_ENTRY_ATTR_BURST_DUR,
+	NL80211_FTM_RESP_ENTRY_ATTR_NEG_BURST_NUM,
+	NL80211_FTM_RESP_ENTRY_ATTR_RSSI,
+	NL80211_FTM_RESP_ENTRY_ATTR_RSSI_SPREAD,
+	NL80211_FTM_RESP_ENTRY_ATTR_TX_RATE_INFO,
+	NL80211_FTM_RESP_ENTRY_ATTR_RX_RATE_INFO,
+	NL80211_FTM_RESP_ENTRY_ATTR_RTT,
+	NL80211_FTM_RESP_ENTRY_ATTR_RTT_VAR,
+	NL80211_FTM_RESP_ENTRY_ATTR_RTT_SPREAD,
+	NL80211_FTM_RESP_ENTRY_ATTR_DISTANCE,
+	NL80211_FTM_RESP_ENTRY_ATTR_DISTANCE_VAR,
+	NL80211_FTM_RESP_ENTRY_ATTR_DISTANCE_SPREAD,
+	NL80211_FTM_RESP_ENTRY_ATTR_LCI,
+	NL80211_FTM_RESP_ENTRY_ATTR_CIVIC,
+	NL80211_FTM_RESP_ENTRY_ATTR_PAD,
+
+	/* keep last */
+	__NL80211_FTM_RESP_ENTRY_ATTR_AFTER_LAST,
+	NL80211_FTM_RESP_ENTRY_ATTR_MAX =
+	__NL80211_FTM_RESP_ENTRY_ATTR_AFTER_LAST - 1,
+};
+
+/**
+ * enum nl80211_ftm_responder_stats - FTM responder statistics
+ *
+ * These attribute types are used with %NL80211_ATTR_FTM_RESPONDER_STATS
+ * when getting FTM responder statistics.
+ *
+ * @__NL80211_FTM_STATS_INVALID: attribute number 0 is reserved
+ * @NL80211_FTM_STATS_SUCCESS_NUM: number of FTM sessions in which all frames
+ *	were ssfully answered (u32)
+ * @NL80211_FTM_STATS_PARTIAL_NUM: number of FTM sessions in which part of the
+ *	frames were successfully answered (u32)
+ * @NL80211_FTM_STATS_FAILED_NUM: number of failed FTM sessions (u32)
+ * @NL80211_FTM_STATS_ASAP_NUM: number of ASAP sessions (u32)
+ * @NL80211_FTM_STATS_NON_ASAP_NUM: number of non-ASAP sessions (u32)
+ * @NL80211_FTM_STATS_TOTAL_DURATION_MSEC: total sessions durations - gives an
+ *	indication of how much time the responder was busy (u64, msec)
+ * @NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM: number of unknown FTM triggers -
+ *	triggers from initiators that didn't finish successfully the negotiation
+ *	phase with the responder (u32)
+ * @NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM: number of FTM reschedule requests
+ *	- initiator asks for a new scheduling although it already has scheduled
+ *	FTM slot (u32)
+ * @NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM: number of FTM triggers out of
+ *	scheduled window (u32)
+ * @NL80211_FTM_STATS_PAD: used for padding, ignore
+ * @__NL80211_TXQ_ATTR_AFTER_LAST: Internal
+ * @NL80211_FTM_STATS_MAX: highest possible FTM responder stats attribute
+ */
+enum nl80211_ftm_responder_stats {
+	__NL80211_FTM_STATS_INVALID,
+	NL80211_FTM_STATS_SUCCESS_NUM,
+	NL80211_FTM_STATS_PARTIAL_NUM,
+	NL80211_FTM_STATS_FAILED_NUM,
+	NL80211_FTM_STATS_ASAP_NUM,
+	NL80211_FTM_STATS_NON_ASAP_NUM,
+	NL80211_FTM_STATS_TOTAL_DURATION_MSEC,
+	NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM,
+	NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM,
+	NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM,
+	NL80211_FTM_STATS_PAD,
+
+	/* keep last */
+	__NL80211_FTM_STATS_AFTER_LAST,
+	NL80211_FTM_STATS_MAX = __NL80211_FTM_STATS_AFTER_LAST - 1
+};
+
 #endif /* __LINUX_NL80211_H */
--- a/net/mac80211/Kconfig
+++ b/net/mac80211/Kconfig
@@ -317,3 +317,8 @@ config MAC80211_STA_HASH_MAX_SIZE
 	  connect more stations than the number selected here.)
 
 	  If unsure, leave the default of 0.
+
+config IWL_TIMEOUT_FACTOR
+	int "Factor to multiply timeouts by"
+	range 1 100
+	default 1
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -1016,6 +1016,7 @@ static int ieee80211_stop_ap(struct wiph
 	sdata->u.ap.driver_smps_mode = IEEE80211_SMPS_OFF;
 
 	__sta_info_flush(sdata, true);
+	ieee80211_free_keys(sdata, true);
 
 	sdata->vif.bss_conf.enable_beacon = false;
 	sdata->vif.bss_conf.ssid_len = 0;
@@ -3535,6 +3536,80 @@ static int ieee80211_del_tx_ts(struct wi
 	return -ENOENT;
 }
 
+static u64 ieee80211_msrment_cookie(struct ieee80211_local *local,
+				    enum nl80211_msrment_type type)
+{
+	ASSERT_RTNL();
+
+	local->msrment_cookie_counter++;
+	if (local->msrment_cookie_counter == (1ULL << 48))
+		local->msrment_cookie_counter = 1;
+
+	return ((u64)type << 48) | local->msrment_cookie_counter;
+}
+
+static int ieee80211_perform_msrment(struct wiphy *wiphy,
+				     struct wireless_dev *wdev,
+				     struct cfg80211_msrment_request *request,
+				     u64 *cookie)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_vif *vif = wdev_to_ieee80211_vif(wdev);
+
+	*cookie = ieee80211_msrment_cookie(local, request->type);
+
+	switch (request->type) {
+	case NL80211_MSRMENT_TYPE_FTM:
+		if (!local->ops->perform_ftm)
+			return -EOPNOTSUPP;
+		return local->ops->perform_ftm(&local->hw, *cookie, vif,
+					       &request->u.ftm);
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static int ieee80211_abort_msrment(struct wiphy *wiphy,
+				   struct wireless_dev *wdev, u64 cookie)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	enum nl80211_msrment_type type = cookie >> 48;
+
+	switch (type) {
+	case NL80211_MSRMENT_TYPE_FTM:
+		if (!local->ops->abort_ftm)
+			return -EOPNOTSUPP;
+		return local->ops->abort_ftm(&local->hw, cookie);
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static int ieee80211_start_ftm_responder(struct wiphy *wiphy,
+					 struct net_device *dev,
+			       struct cfg80211_ftm_responder_params *params)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	return drv_start_ftm_responder(local, sdata, params);
+}
+
+static int ieee80211_get_ftm_responder_stats(struct wiphy *wiphy,
+					    struct net_device *dev,
+			       struct cfg80211_ftm_responder_stats *ftm_stats)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	return drv_get_ftm_responder_stats(local, sdata, ftm_stats);
+}
+
 void ieee80211_nan_func_terminated(struct ieee80211_vif *vif,
 				   u8 inst_id,
 				   enum nl80211_nan_func_term_reason reason,
@@ -3542,6 +3617,7 @@ void ieee80211_nan_func_terminated(struc
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct cfg80211_nan_func *func;
+	struct wireless_dev *wdev;
 	u64 cookie;
 
 	if (WARN_ON(vif->type != NL80211_IFTYPE_NAN))
@@ -3562,8 +3638,10 @@ void ieee80211_nan_func_terminated(struc
 
 	cfg80211_free_nan_func(func);
 
-	cfg80211_nan_func_terminated(ieee80211_vif_to_wdev(vif), inst_id,
-				     reason, cookie, gfp);
+	wdev = ieee80211_vif_to_wdev(vif);
+	if (!WARN_ON_ONCE(!wdev))
+		cfg80211_nan_func_terminated(wdev, inst_id,
+					     reason, cookie, gfp);
 }
 EXPORT_SYMBOL(ieee80211_nan_func_terminated);
 
@@ -3573,6 +3651,7 @@ void ieee80211_nan_func_match(struct iee
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct cfg80211_nan_func *func;
+	struct wireless_dev *wdev;
 
 	if (WARN_ON(vif->type != NL80211_IFTYPE_NAN))
 		return;
@@ -3588,7 +3667,9 @@ void ieee80211_nan_func_match(struct iee
 
 	spin_unlock_bh(&sdata->u.nan.func_lock);
 
-	cfg80211_nan_match(ieee80211_vif_to_wdev(vif), match, gfp);
+	wdev = ieee80211_vif_to_wdev(vif);
+	if (!WARN_ON_ONCE(!wdev))
+		cfg80211_nan_match(wdev, match, gfp);
 }
 EXPORT_SYMBOL(ieee80211_nan_func_match);
 
@@ -3612,6 +3693,10 @@ const struct cfg80211_ops mac80211_confi
 	.get_station = ieee80211_get_station,
 	.dump_station = ieee80211_dump_station,
 	.dump_survey = ieee80211_dump_survey,
+	.perform_msrment = ieee80211_perform_msrment,
+	.abort_msrment = ieee80211_abort_msrment,
+	.start_ftm_responder = ieee80211_start_ftm_responder,
+	.get_ftm_responder_stats = ieee80211_get_ftm_responder_stats,
 #ifdef CPTCFG_MAC80211_MESH
 	.add_mpath = ieee80211_add_mpath,
 	.del_mpath = ieee80211_del_mpath,
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@ -211,6 +211,7 @@ static const char *hw_flag_names[] = {
 	FLAG(TX_FRAG_LIST),
 	FLAG(REPORTS_LOW_ACK),
 	FLAG(NEEDS_ALIGNED4_SKBS),
+	FLAG(SUPPORTS_TX_FRAG),
 #undef FLAG
 };
 
--- a/net/mac80211/driver-ops.h
+++ b/net/mac80211/driver-ops.h
@@ -1248,4 +1248,36 @@ static inline void drv_del_nan_func(stru
 	trace_drv_return_void(local);
 }
 
+static inline int
+drv_start_ftm_responder(struct ieee80211_local *local,
+			struct ieee80211_sub_if_data *sdata,
+			struct cfg80211_ftm_responder_params *params)
+{
+	u32 ret = -EOPNOTSUPP;
+
+	trace_drv_start_ftm_responder(local, sdata);
+	if (local->ops->start_ftm_responder)
+		ret = local->ops->start_ftm_responder(&local->hw, &sdata->vif,
+						      params);
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
+static inline int
+drv_get_ftm_responder_stats(struct ieee80211_local *local,
+			    struct ieee80211_sub_if_data *sdata,
+			    struct cfg80211_ftm_responder_stats *ftm_stats)
+{
+	u32 ret = -EOPNOTSUPP;
+
+	if (local->ops->get_ftm_responder_stats)
+		ret = local->ops->get_ftm_responder_stats(&local->hw,
+							 &sdata->vif,
+							 ftm_stats);
+	trace_drv_get_ftm_responder_stats(local, sdata, ftm_stats);
+
+	return ret;
+}
+
 #endif /* __MAC80211_DRIVER_OPS */
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -84,6 +84,8 @@ struct ieee80211_local;
 #define IEEE80211_DEFAULT_MAX_SP_LEN		\
 	IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL
 
+extern const u8 ieee80211_ac_to_qos_mask[IEEE80211_NUM_ACS];
+
 #define IEEE80211_DEAUTH_FRAME_LEN	(24 /* hdr */ + 2 /* reason */)
 
 #define IEEE80211_MAX_NAN_INSTANCE_ID 255
@@ -1395,11 +1397,19 @@ struct ieee80211_local {
 	struct cfg80211_chan_def monitor_chandef;
 
 	/* extended capabilities provided by mac80211 */
-	u8 ext_capa[8];
+	u8 ext_capa[9];
 
 	/* TDLS channel switch */
 	struct work_struct tdls_chsw_work;
 	struct sk_buff_head skb_queue_tdls_chsw;
+
+	u64 msrment_cookie_counter;
+
+	struct uapsd_black_list {
+		struct rcu_head rcu_head;
+		unsigned int num_oui;
+		unsigned int oui[];
+	} *uapsd_black_list;
 };
 
 static inline struct ieee80211_sub_if_data *
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -6,6 +6,7 @@
  * Copyright (c) 2006 Jiri Benc <jbenc@suse.cz>
  * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
  * Copyright 2013-2014  Intel Mobile Communications GmbH
+ * Copyright (c) 2016        Intel Deutschland GmbH
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -1330,6 +1331,26 @@ static void ieee80211_iface_work(struct
 		} else if (ieee80211_is_action(mgmt->frame_control) &&
 			   mgmt->u.action.category == WLAN_CATEGORY_VHT) {
 			switch (mgmt->u.action.u.vht_group_notif.action_code) {
+			case WLAN_VHT_ACTION_OPMODE_NOTIF: {
+				struct ieee80211_rx_status *status;
+				enum nl80211_band band;
+				u8 opmode;
+
+				status = IEEE80211_SKB_RXCB(skb);
+				band = status->band;
+				opmode = mgmt->u.action.u.vht_opmode_notif.operating_mode;
+
+				mutex_lock(&local->sta_mtx);
+				sta = sta_info_get_bss(sdata, mgmt->sa);
+
+				if (sta)
+					ieee80211_vht_handle_opmode(sdata, sta,
+								    opmode,
+								    band);
+
+				mutex_unlock(&local->sta_mtx);
+				break;
+			}
 			case WLAN_VHT_ACTION_GROUPID_MGMT:
 				ieee80211_process_mu_groups(sdata, mgmt);
 				break;
--- /dev/null
+++ b/net/mac80211/packet_filtering.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2013-2014  Intel Mobile Communications GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Packet filtering
+ *
+ * Checks if differnt type of packets should be filterd.
+ *	1. Gratuitous ARP
+ *	2. Unsolicited Neighbor Advertisement
+ *	3. Frames Encrypted using the GTK
+ */
+
+#ifndef PACKET_FILTER_H
+#define PACKET_FILTER_H
+#include <linux/if_arp.h>
+#include <net/ip_fib.h>
+#include <net/ip.h>
+#include <net/ndisc.h>
+#include <net/ipv6.h>
+
+/**
+ * ieee80211_is_shared_gtk - packet is GTK
+ * @skb: the input packet, must be an ethernet frame already
+ *
+ * Return: %true if the packet is Encrypted using the GTK .
+ * This is used to drop packets that shouldn't occur because the AP implements
+ * a proxy service.
+ */
+static inline bool ieee80211_is_shared_gtk(struct sk_buff *skb)
+{
+	const struct ethhdr *eth = (void *)skb->data;
+	const struct iphdr *ipv4;
+	const struct ipv6hdr *ipv6;
+	const struct in6_addr *saddr;
+	struct fib_result res;
+	struct flowi4 fl4;
+
+	switch (eth->h_proto) {
+	case cpu_to_be16(ETH_P_IP):
+		ipv4 = (void *)(eth + 1);
+		fl4.daddr = ipv4->daddr;
+		fl4.saddr = ipv4->saddr;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+		if (!fib_lookup(dev_net(skb->dev), &fl4, &res))
+#else
+		if (!fib_lookup(dev_net(skb->dev), &fl4, &res, 0))
+#endif
+			if (res.type == RTN_MULTICAST ||
+			    res.type == RTN_BROADCAST)
+				return true;
+		break;
+	case cpu_to_be16(ETH_P_IPV6):
+		ipv6 = (void *)(eth + 1);
+		saddr = &ipv6->saddr;
+
+		if (ipv6_addr_is_multicast(saddr))
+			return true;
+	}
+
+	return false;
+}
+
+/**
+ * ieee80211_is_gratuitous_arp_unsolicited_na - packet is grat. ARP/unsol. NA
+ * @skb: the input packet, must be an ethernet frame already
+ *
+ * Return: %true if the packet is a gratuitous ARP or unsolicited NA packet.
+ * This is used to drop packets that shouldn't occur because the AP implements
+ * a proxy service.
+ */
+static inline bool
+ieee80211_is_gratuitous_arp_unsolicited_na(struct sk_buff *skb)
+{
+	const struct ethhdr *eth = (void *)skb->data;
+
+	const struct {
+		struct arphdr hdr;
+		u8 ar_sha[ETH_ALEN];
+		u8 ar_sip[4];
+		u8 ar_tha[ETH_ALEN];
+		u8 ar_tip[4];
+	} __packed *arp;
+	const struct ipv6hdr *ipv6;
+	const struct icmp6hdr *icmpv6;
+
+	switch (eth->h_proto) {
+	case cpu_to_be16(ETH_P_ARP):
+		/* can't say - but will probably be dropped later anyway */
+		if (!pskb_may_pull(skb, sizeof(*eth) + sizeof(*arp)))
+			return false;
+
+		arp = (void *)(eth + 1);
+
+		if ((arp->hdr.ar_op == cpu_to_be16(ARPOP_REPLY) ||
+		     arp->hdr.ar_op == cpu_to_be16(ARPOP_REQUEST)) &&
+		    !memcmp(arp->ar_sip, arp->ar_tip, sizeof(arp->ar_sip)))
+			return true;
+		break;
+	case cpu_to_be16(ETH_P_IPV6):
+		/* can't say - but will probably be dropped later anyway */
+		if (!pskb_may_pull(skb, sizeof(*eth) + sizeof(*ipv6) +
+					sizeof(*icmpv6)))
+			return false;
+
+		ipv6 = (void *)(eth + 1);
+		icmpv6 = (void *)(ipv6 + 1);
+
+		if (icmpv6->icmp6_type == NDISC_NEIGHBOUR_ADVERTISEMENT &&
+		    !icmpv6->icmp6_solicited)
+			return true;
+		break;
+	default:
+		/*
+		 * no need to support other protocols, proxy service isn't
+		 * specified for any others
+		 */
+		break;
+	}
+
+	return false;
+}
+
+#endif /* PACKET_FILTER_H */
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -25,6 +25,9 @@
 #include <asm/unaligned.h>
 
 #include "ieee80211_i.h"
+#ifdef CPTCFG_IWLMVM_VENDOR_CMDS
+#include "packet_filtering.h"
+#endif
 #include "driver-ops.h"
 #include "led.h"
 #include "mesh.h"
@@ -1394,13 +1397,15 @@ void ieee80211_sta_uapsd_trigger(struct
 	u8 ac = ieee802_1d_to_ac[tid & 7];
 
 	/*
-	 * If this AC is not trigger-enabled do nothing.
+	 * If this AC is not trigger-enabled do nothing unless the
+	 * driver is calling us after it already checked.
 	 *
 	 * NB: This could/should check a separate bitmap of trigger-
 	 * enabled queues, but for now we only implement uAPSD w/o
 	 * TSPEC changes to the ACs, so they're always the same.
 	 */
-	if (!(sta->sta.uapsd_queues & BIT(ac)))
+	if (!(sta->sta.uapsd_queues & ieee80211_ac_to_qos_mask[ac]) &&
+	    tid != IEEE80211_NUM_TIDS)
 		return;
 
 	/* if we are in a service period, do nothing */
@@ -2198,6 +2203,23 @@ ieee80211_deliver_skb(struct ieee80211_r
 	skb = rx->skb;
 	xmit_skb = NULL;
 
+#ifdef CPTCFG_IWLMVM_VENDOR_CMDS
+	/*
+	 * Filter packets in case that configured to do so by user space,
+	 * and we are associated to an Hotspot AP and have an IP address.
+	 */
+	if (sdata->vif.filter_grat_arp_unsol_na &&
+	    sdata->vif.bss_conf.arp_addr_cnt &&
+	    ieee80211_is_gratuitous_arp_unsolicited_na(skb)) {
+		dev_kfree_skb(skb);
+		return;
+	}
+	if (sdata->vif.filter_gtk && sdata->vif.bss_conf.arp_addr_cnt &&
+	    ieee80211_is_shared_gtk(skb)) {
+		dev_kfree_skb(skb);
+		return;
+	}
+#endif
 	ieee80211_rx_stats(dev, skb->len);
 
 	if (rx->sta) {
@@ -2298,6 +2320,8 @@ ieee80211_rx_h_amsdu(struct ieee80211_rx
 	__le16 fc = hdr->frame_control;
 	struct sk_buff_head frame_list;
 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+	struct ethhdr ethhdr;
+	const u8 *check_da = ethhdr.h_dest, *check_sa = ethhdr.h_source;
 
 	if (unlikely(!ieee80211_is_data(fc)))
 		return RX_CONTINUE;
@@ -2308,24 +2332,53 @@ ieee80211_rx_h_amsdu(struct ieee80211_rx
 	if (!(status->rx_flags & IEEE80211_RX_AMSDU))
 		return RX_CONTINUE;
 
-	if (ieee80211_has_a4(hdr->frame_control) &&
-	    rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&
-	    !rx->sdata->u.vlan.sta)
-		return RX_DROP_UNUSABLE;
+	if (unlikely(ieee80211_has_a4(hdr->frame_control))) {
+		switch (rx->sdata->vif.type) {
+		case NL80211_IFTYPE_AP_VLAN:
+			if (!rx->sdata->u.vlan.sta)
+				return RX_DROP_UNUSABLE;
+			break;
+		case NL80211_IFTYPE_STATION:
+			if (!rx->sdata->u.mgd.use_4addr)
+				return RX_DROP_UNUSABLE;
+			break;
+		default:
+			return RX_DROP_UNUSABLE;
+		}
+		check_da = NULL;
+		check_sa = NULL;
+	} else switch (rx->sdata->vif.type) {
+		case NL80211_IFTYPE_AP:
+		case NL80211_IFTYPE_AP_VLAN:
+			check_da = NULL;
+			break;
+		case NL80211_IFTYPE_STATION:
+			if (!rx->sta ||
+			    !test_sta_flag(rx->sta, WLAN_STA_TDLS_PEER))
+				check_sa = NULL;
+			break;
+		case NL80211_IFTYPE_MESH_POINT:
+			check_sa = NULL;
+			break;
+		default:
+			break;
+	}
 
-	if (is_multicast_ether_addr(hdr->addr1) &&
-	    ((rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&
-	      rx->sdata->u.vlan.sta) ||
-	     (rx->sdata->vif.type == NL80211_IFTYPE_STATION &&
-	      rx->sdata->u.mgd.use_4addr)))
+	if (is_multicast_ether_addr(hdr->addr1))
 		return RX_DROP_UNUSABLE;
 
 	skb->dev = dev;
 	__skb_queue_head_init(&frame_list);
 
+	if (ieee80211_data_to_8023_exthdr(skb, &ethhdr,
+					  rx->sdata->vif.addr,
+					  rx->sdata->vif.type))
+		return RX_DROP_UNUSABLE;
+
 	ieee80211_amsdu_to_8023s(skb, &frame_list, dev->dev_addr,
 				 rx->sdata->vif.type,
-				 rx->local->hw.extra_tx_headroom, true);
+				 rx->local->hw.extra_tx_headroom,
+				 check_da, check_sa);
 
 	while (!skb_queue_empty(&frame_list)) {
 		rx->skb = __skb_dequeue(&frame_list);
@@ -3695,6 +3748,12 @@ void ieee80211_check_fast_rx(struct sta_
 		fastrx.icv_len = key->conf.icv_len;
 	}
 
+#ifdef CPTCFG_IWLMVM_VENDOR_CMDS
+	if (sdata->vif.filter_grat_arp_unsol_na &&
+	    sdata->vif.bss_conf.arp_addr_cnt)
+		fastrx.drop_grat_arp_unsol_na = true;
+#endif
+
 	assign = true;
  clear_rcu:
 	rcu_read_unlock();
@@ -3895,6 +3954,12 @@ static bool ieee80211_invoke_fast_rx(str
 
 	skb->dev = fast_rx->dev;
 
+#ifdef CPTCFG_IWLMVM_VENDOR_CMDS
+	if (fast_rx->drop_grat_arp_unsol_na &&
+	    ieee80211_is_gratuitous_arp_unsolicited_na(skb))
+		goto drop;
+#endif
+
 	ieee80211_rx_stats(fast_rx->dev, skb->len);
 
 	/* The seqno index has the same property as needed
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -709,7 +709,7 @@ static void __sta_info_recalc_tim(struct
 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
 		unsigned long tids;
 
-		if (ignore_for_tim & BIT(ac))
+		if (ignore_for_tim & ieee80211_ac_to_qos_mask[ac])
 			continue;
 
 		indicate_tim |= !skb_queue_empty(&sta->tx_filtered[ac]) ||
@@ -1389,7 +1389,7 @@ ieee80211_sta_ps_more_data(struct sta_in
 		return true;
 
 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-		if (ignored_acs & BIT(ac))
+		if (ignored_acs & ieee80211_ac_to_qos_mask[ac])
 			continue;
 
 		if (!skb_queue_empty(&sta->tx_filtered[ac]) ||
@@ -1414,7 +1414,7 @@ ieee80211_sta_ps_get_frames(struct sta_i
 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
 		unsigned long tids;
 
-		if (ignored_acs & BIT(ac))
+		if (ignored_acs & ieee80211_ac_to_qos_mask[ac])
 			continue;
 
 		tids = ieee80211_tids_for_ac(ac);
@@ -1482,7 +1482,7 @@ ieee80211_sta_ps_deliver_response(struct
 			BIT(find_highest_prio_tid(driver_release_tids));
 
 	if (skb_queue_empty(&frames) && !driver_release_tids) {
-		int tid;
+		int tid, ac;
 
 		/*
 		 * For PS-Poll, this can only happen due to a race condition
@@ -1500,7 +1500,10 @@ ieee80211_sta_ps_deliver_response(struct
 		 */
 
 		/* This will evaluate to 1, 3, 5 or 7. */
-		tid = 7 - ((ffs(~ignored_acs) - 1) << 1);
+		for (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ac++)
+			if (ignored_acs & BIT(ac))
+				continue;
+		tid = 7 - 2 * ac;
 
 		ieee80211_send_null_response(sta, tid, reason, true, false);
 	} else if (!driver_release_tids) {
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@ -2574,6 +2574,35 @@ TRACE_EVENT(drv_wake_tx_queue,
 	)
 );
 
+DEFINE_EVENT(local_sdata_evt, drv_start_ftm_responder,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata)
+);
+
+TRACE_EVENT(drv_get_ftm_responder_stats,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 struct cfg80211_ftm_responder_stats *ftm_stats),
+
+	TP_ARGS(local, sdata, ftm_stats),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT VIF_PR_FMT,
+		LOCAL_PR_ARG, VIF_PR_ARG
+	)
+);
+
 #endif /* !__MAC80211_DRIVER_TRACE || TRACE_HEADER_MULTI_READ */
 
 #undef TRACE_INCLUDE_PATH
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -3460,3 +3460,10 @@ void ieee80211_txq_get_depth(struct ieee
 		*byte_cnt = txqi->tin.backlog_bytes + frag_bytes;
 }
 EXPORT_SYMBOL(ieee80211_txq_get_depth);
+
+const u8 ieee80211_ac_to_qos_mask[IEEE80211_NUM_ACS] = {
+	IEEE80211_WMM_IE_STA_QOSINFO_AC_VO,
+	IEEE80211_WMM_IE_STA_QOSINFO_AC_VI,
+	IEEE80211_WMM_IE_STA_QOSINFO_AC_BE,
+	IEEE80211_WMM_IE_STA_QOSINFO_AC_BK
+};
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -3,7 +3,7 @@
  *
  * Copyright 2006-2010		Johannes Berg <johannes@sipsolutions.net>
  * Copyright 2013-2014  Intel Mobile Communications GmbH
- * Copyright 2015	Intel Deutschland GmbH
+ * Copyright 2015-2016	Intel Deutschland GmbH
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
@@ -357,6 +357,33 @@ static void cfg80211_sched_scan_stop_wk(
 	rtnl_unlock();
 }
 
+static void cfg80211_abort_msrment_wk(struct work_struct *work)
+{
+	struct cfg80211_registered_device *rdev;
+	struct cfg80211_active_msrment *msrment, *tmp;
+	LIST_HEAD(msrments_list);
+
+	rdev = container_of(work, struct cfg80211_registered_device,
+			    msrment_abort_wk);
+
+	spin_lock_bh(&rdev->msrments_lock);
+	list_for_each_entry_safe(msrment, tmp, &rdev->msrments_list, list) {
+		if (msrment->nl_portid != 0)
+			continue;
+		list_del(&msrment->list);
+		list_add(&msrment->list, &msrments_list);
+	}
+	spin_unlock_bh(&rdev->msrments_lock);
+
+	rtnl_lock();
+	list_for_each_entry_safe(msrment, tmp, &msrments_list, list) {
+		rdev_abort_msrment(rdev, msrment->wdev, msrment->cookie);
+		list_del(&msrment->list);
+		kfree(msrment);
+	}
+	rtnl_unlock();
+}
+
 /* exported functions */
 
 struct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,
@@ -447,6 +474,9 @@ use_default_name:
 	spin_lock_init(&rdev->beacon_registrations_lock);
 	spin_lock_init(&rdev->bss_lock);
 	INIT_LIST_HEAD(&rdev->bss_list);
+	spin_lock_init(&rdev->msrments_lock);
+	INIT_LIST_HEAD(&rdev->msrments_list);
+	INIT_WORK(&rdev->msrment_abort_wk, cfg80211_abort_msrment_wk);
 	INIT_WORK(&rdev->scan_done_wk, __cfg80211_scan_done);
 	INIT_WORK(&rdev->sched_scan_results_wk, __cfg80211_sched_scan_results);
 	INIT_LIST_HEAD(&rdev->mlme_unreg);
@@ -667,6 +697,10 @@ int wiphy_register(struct wiphy *wiphy)
 		     !rdev->ops->set_mac_acl)))
 		return -EINVAL;
 
+	if (WARN_ON((wiphy->ftm_initiator_capa) &&
+		    (!rdev->ops->perform_msrment || !rdev->ops->abort_msrment)))
+		return -EINVAL;
+
 	/* assure only valid behaviours are flagged by driver
 	 * hence subtract 2 as bit 0 is invalid.
 	 */
@@ -867,6 +901,9 @@ void wiphy_unregister(struct wiphy *wiph
 		rfkill_unregister(rdev->rfkill);
 
 	rtnl_lock();
+	/* since we no longer have any wdevs, the list should be empty */
+	WARN_ON(!list_empty(&rdev->msrments_list));
+
 	nl80211_notify_wiphy(rdev, NL80211_CMD_DEL_WIPHY);
 	rdev->wiphy.registered = false;
 
@@ -898,6 +935,7 @@ void wiphy_unregister(struct wiphy *wiph
 	flush_work(&rdev->destroy_work);
 	flush_work(&rdev->sched_scan_stop_wk);
 	flush_work(&rdev->mlme_unreg_wk);
+	flush_work(&rdev->msrment_abort_wk);
 
 #ifdef CONFIG_PM
 	if (rdev->wiphy.wowlan_config && rdev->ops->set_wakeup)
@@ -986,6 +1024,28 @@ void cfg80211_update_iface_num(struct cf
 		rdev->num_running_monitor_ifaces += num;
 }
 
+static void cfg80211_abort_all_msrments(struct cfg80211_registered_device *rdev,
+					struct wireless_dev *wdev)
+{
+	struct cfg80211_active_msrment *msrment, *tmp;
+	LIST_HEAD(msrments_list);
+
+	spin_lock_bh(&rdev->msrments_lock);
+	list_for_each_entry_safe(msrment, tmp, &rdev->msrments_list, list) {
+		if (msrment->wdev != wdev)
+			continue;
+		list_del(&msrment->list);
+		list_add(&msrment->list, &msrments_list);
+	}
+	spin_unlock_bh(&rdev->msrments_lock);
+
+	list_for_each_entry_safe(msrment, tmp, &msrments_list, list) {
+		rdev_abort_msrment(rdev, wdev, msrment->cookie);
+		list_del(&msrment->list);
+		kfree(msrment);
+	}
+}
+
 void __cfg80211_leave(struct cfg80211_registered_device *rdev,
 		      struct wireless_dev *wdev)
 {
@@ -995,6 +1055,8 @@ void __cfg80211_leave(struct cfg80211_re
 	ASSERT_RTNL();
 	ASSERT_WDEV_LOCK(wdev);
 
+	cfg80211_abort_all_msrments(rdev, wdev);
+
 	switch (wdev->iftype) {
 	case NL80211_IFTYPE_ADHOC:
 		__cfg80211_leave_ibss(rdev, dev, true);
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -2,6 +2,7 @@
  * Wireless configuration interface internals.
  *
  * Copyright 2006-2010	Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2015-2016	Intel Deutschland GmbH
  */
 #ifndef __NET_WIRELESS_CORE_H
 #define __NET_WIRELESS_CORE_H
@@ -63,6 +64,10 @@ struct cfg80211_registered_device {
 	spinlock_t mlme_unreg_lock;
 	struct work_struct mlme_unreg_wk;
 
+	spinlock_t msrments_lock;
+	struct list_head msrments_list;
+	struct work_struct msrment_abort_wk;
+
 	/* protected by RTNL only */
 	int num_running_ifaces;
 	int num_running_monitor_ifaces;
@@ -272,6 +277,13 @@ struct cfg80211_iface_destroy {
 	u32 nlportid;
 };
 
+struct cfg80211_active_msrment {
+	struct wireless_dev *wdev;
+	struct list_head list;
+	u64 cookie;
+	u32 nl_portid;
+};
+
 void cfg80211_destroy_ifaces(struct cfg80211_registered_device *rdev);
 
 /* free object */
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -418,6 +418,15 @@ static const struct nla_policy nl80211_p
 	[NL80211_ATTR_NAN_DUAL] = { .type = NLA_U8 },
 	[NL80211_ATTR_NAN_FUNC] = { .type = NLA_NESTED },
 	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
+	[NL80211_ATTR_MSRMENT_TYPE] = { .type = NLA_U32 },
+	[NL80211_ATTR_MSRMENT_STATUS] = { .type = NLA_U8 },
+	[NL80211_ATTR_MSRMENT_FTM_REQUEST] = { .type = NLA_NESTED },
+	[NL80211_ATTR_MSRMENT_FTM_RESPONSE] = { .type = NLA_NESTED },
+	[NL80211_ATTR_MSRMENT_FTM_CAPA] = { .type = NLA_NESTED },
+	[NL80211_ATTR_LAST_MSG] = { .type = NLA_FLAG },
+	[NL80211_ATTR_LCI] = { .type = NLA_BINARY },
+	[NL80211_ATTR_CIVIC] = { .type = NLA_BINARY },
+	[NL80211_ATTR_PMK] = { .len = WLAN_PMK_LEN },
 };
 
 /* policy for the key attributes */
@@ -1333,6 +1342,34 @@ struct nl80211_dump_wiphy_state {
 	bool split;
 };
 
+static int
+nl80211_put_ftm_initiator_capa(struct cfg80211_registered_device *rdev,
+			       struct sk_buff *msg)
+{
+	const struct wiphy_ftm_initiator_capa *capa =
+		rdev->wiphy.ftm_initiator_capa;
+	struct nlattr *capabs = nla_nest_start(msg,
+					       NL80211_ATTR_MSRMENT_FTM_CAPA);
+
+	if (!capabs || nla_put_u32(msg, NL80211_FTM_CAPA_MAX_2_SIDED,
+				   capa->max_two_sided_ftm_targets) ||
+	    nla_put_u32(msg, NL80211_FTM_CAPA_MAX_TOTAL,
+			capa->max_total_ftm_targets) ||
+	    (capa->asap && nla_put_flag(msg, NL80211_FTM_CAPA_ASAP)) ||
+	    (capa->non_asap && nla_put_flag(msg, NL80211_FTM_CAPA_NON_ASAP)) ||
+	    (capa->req_tsf && nla_put_flag(msg, NL80211_FTM_CAPA_REQ_TSF)) ||
+	    (capa->req_lci && nla_put_flag(msg, NL80211_FTM_CAPA_REQ_LCI)) ||
+	    (capa->req_civic &&
+	     nla_put_flag(msg, NL80211_FTM_CAPA_REQ_CIVIC)) ||
+	    nla_put_u32(msg, NL80211_FTM_CAPA_PREAMBLE, capa->preamble) ||
+	    nla_put_u32(msg, NL80211_FTM_CAPA_BW, capa->bw))
+		return -ENOBUFS;
+
+	nla_nest_end(msg, capabs);
+
+	return 0;
+}
+
 static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 			      enum nl80211_commands cmd,
 			      struct sk_buff *msg, u32 portid, u32 seq,
@@ -1467,6 +1504,11 @@ static int nl80211_send_wiphy(struct cfg
 		if (nl80211_put_iftypes(msg, NL80211_ATTR_SUPPORTED_IFTYPES,
 					rdev->wiphy.interface_modes))
 				goto nla_put_failure;
+
+		if ((rdev->wiphy.ftm_initiator_capa) &&
+		    nl80211_put_ftm_initiator_capa(rdev, msg))
+			goto nla_put_failure;
+
 		state->split_start++;
 		if (state->split)
 			break;
@@ -1624,6 +1666,8 @@ static int nl80211_send_wiphy(struct cfg
 			if (rdev->wiphy.features &
 					NL80211_FEATURE_SUPPORTS_WMM_ADMISSION)
 				CMD(add_tx_ts, ADD_TX_TS);
+			if (rdev->wiphy.flags & WIPHY_FLAG_HAS_FTM_RESPONDER)
+				CMD(start_ftm_responder, START_FTM_RESPONDER);
 		}
 		/* add into the if now */
 #undef CMD
@@ -4613,6 +4657,15 @@ int cfg80211_check_station_change(struct
 		break;
 	}
 
+	/*
+	 * Older kernel versions ignored this attribute entirely, so don't
+	 * reject attempts to update it but mark it as unused instead so the
+	 * driver won't look at the data.
+	 */
+	if (statype != CFG80211_STA_AP_CLIENT_UNASSOC &&
+	    statype != CFG80211_STA_TDLS_PEER_SETUP)
+		params->opmode_notif_used = false;
+
 	return 0;
 }
 EXPORT_SYMBOL(cfg80211_check_station_change);
@@ -4852,6 +4905,12 @@ static int nl80211_set_station(struct sk
 		params.local_pm = pm;
 	}
 
+	if (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {
+		params.opmode_notif_used = true;
+		params.opmode_notif =
+			nla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);
+	}
+
 	/* Include parameters for TDLS peer (will check later) */
 	err = nl80211_set_station_tdls(info, &params);
 	if (err)
@@ -6461,12 +6520,13 @@ static int parse_bss_select(struct nlatt
 	return 0;
 }
 
-static int nl80211_parse_random_mac(struct nlattr **attrs,
+static int nl80211_parse_random_mac(struct nlattr *mac_attr,
+				    struct nlattr *mac_mask_attr,
 				    u8 *mac_addr, u8 *mac_addr_mask)
 {
 	int i;
 
-	if (!attrs[NL80211_ATTR_MAC] && !attrs[NL80211_ATTR_MAC_MASK]) {
+	if (!mac_attr && !mac_mask_attr) {
 		eth_zero_addr(mac_addr);
 		eth_zero_addr(mac_addr_mask);
 		mac_addr[0] = 0x2;
@@ -6476,11 +6536,11 @@ static int nl80211_parse_random_mac(stru
 	}
 
 	/* need both or none */
-	if (!attrs[NL80211_ATTR_MAC] || !attrs[NL80211_ATTR_MAC_MASK])
+	if (!mac_attr || !mac_mask_attr)
 		return -EINVAL;
 
-	memcpy(mac_addr, nla_data(attrs[NL80211_ATTR_MAC]), ETH_ALEN);
-	memcpy(mac_addr_mask, nla_data(attrs[NL80211_ATTR_MAC_MASK]), ETH_ALEN);
+	memcpy(mac_addr, nla_data(mac_attr), ETH_ALEN);
+	memcpy(mac_addr_mask, nla_data(mac_mask_attr), ETH_ALEN);
 
 	/* don't allow or configure an mcast address */
 	if (!is_multicast_ether_addr(mac_addr_mask) ||
@@ -6705,9 +6765,10 @@ static int nl80211_trigger_scan(struct s
 				goto out_free;
 			}
 
-			err = nl80211_parse_random_mac(info->attrs,
-						       request->mac_addr,
-						       request->mac_addr_mask);
+			err = nl80211_parse_random_mac(
+				info->attrs[NL80211_ATTR_MAC],
+				info->attrs[NL80211_ATTR_MAC_MASK],
+				request->mac_addr, request->mac_addr_mask);
 			if (err)
 				goto out_free;
 		}
@@ -7148,8 +7209,9 @@ nl80211_parse_sched_scan(struct wiphy *w
 				goto out_free;
 			}
 
-			err = nl80211_parse_random_mac(attrs, request->mac_addr,
-						       request->mac_addr_mask);
+			err = nl80211_parse_random_mac(attrs[NL80211_ATTR_MAC],
+				attrs[NL80211_ATTR_MAC_MASK], request->mac_addr,
+				request->mac_addr_mask);
 			if (err)
 				goto out_free;
 		}
@@ -7940,6 +8002,13 @@ static int nl80211_crypto_settings(struc
 		memcpy(settings->akm_suites, data, len);
 	}
 
+	if (info->attrs[NL80211_ATTR_PMK]) {
+		if (!wiphy_ext_feature_isset(&rdev->wiphy,
+					     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_OFFLOAD_STA))
+			return -EINVAL;
+		settings->psk = nla_data(info->attrs[NL80211_ATTR_PMK]);
+	}
+
 	return 0;
 }
 
@@ -8841,6 +8910,14 @@ static int nl80211_setdel_pmksa(struct s
 
 	pmksa.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);
 	pmksa.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);
+	if (info->attrs[NL80211_ATTR_PMK]) {
+		pmksa.pmk = nla_data(info->attrs[NL80211_ATTR_PMK]);
+		pmksa.pmk_len = nla_len(info->attrs[NL80211_ATTR_PMK]);
+		if (pmksa.pmk_len != WLAN_PMK_LEN &&
+		    pmksa.pmk_len != WLAN_PMK_LEN_SUITE_B_192 &&
+		    pmksa.pmk_len != WLAN_PMK_LEN_EAP_LEAP)
+			return -EINVAL;
+	}
 
 	if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&
 	    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)
@@ -11297,7 +11374,8 @@ static int nl80211_vendor_cmd(struct sk_
 				if (wdev->netdev &&
 				    !netif_running(wdev->netdev))
 					return -ENETDOWN;
-				if (!wdev->netdev && !wdev->p2p_started)
+				if (!wdev->netdev && !wdev->p2p_started &&
+				    !wdev->nan_started)
 					return -ENETDOWN;
 			}
 
@@ -11776,6 +11854,396 @@ static int nl80211_tdls_cancel_channel_s
 	return 0;
 }
 
+/* policy for the attributes of a single ftm target */
+static const struct nla_policy
+nl80211_ftm_target_policy[NL80211_FTM_TARGET_ATTR_MAX + 1] = {
+	[NL80211_FTM_TARGET_ATTR_FREQ] = { .type = NLA_U32 },
+	[NL80211_FTM_TARGET_ATTR_BW] = { .type = NLA_U8 },
+	[NL80211_FTM_TARGET_ATTR_CNTR_FREQ_1] = { .type = NLA_U32 },
+	[NL80211_FTM_TARGET_ATTR_CNTR_FREQ_2] = { .type = NLA_U32 },
+	[NL80211_FTM_TARGET_ATTR_BSSID] = { .len = ETH_ALEN },
+	[NL80211_FTM_TARGET_ATTR_ONE_SIDED] = { .type = NLA_FLAG },
+	[NL80211_FTM_TARGET_ATTR_NUM_OF_BURSTS_EXP] = { .type = NLA_U8 },
+	[NL80211_FTM_TARGET_ATTR_BURST_PERIOD] = { .type = NLA_U16 },
+	[NL80211_FTM_TARGET_ATTR_SAMPLES_PER_BURST] = { .type = NLA_U8 },
+	[NL80211_FTM_TARGET_ATTR_RETRIES] = { .type = NLA_U8 },
+	[NL80211_FTM_TARGET_ATTR_BURST_DURATION] = { .type = NLA_U8},
+	[NL80211_FTM_TARGET_ATTR_ASAP] = { .type = NLA_FLAG },
+	[NL80211_FTM_TARGET_ATTR_QUERY_LCI] = { .type = NLA_FLAG },
+	[NL80211_FTM_TARGET_ATTR_QUERY_CIVIC] = { .type = NLA_FLAG },
+	[NL80211_FTM_TARGET_ATTR_COOKIE] = { .type = NLA_U64 },
+	[NL80211_FTM_TARGET_ATTR_FTM_PREAMBLE] = { .type = NLA_U8},
+	[NL80211_FTM_TARGET_ATTR_FTM_BW] = { .type = NLA_U8},
+};
+
+static int nl80211_parse_ftm_target(struct cfg80211_registered_device *rdev,
+				    struct nlattr *ftm_target_attr,
+				    struct cfg80211_ftm_target *target)
+{
+	struct nlattr *tb[NL80211_FTM_TARGET_ATTR_MAX + 1];
+	const struct wiphy_ftm_initiator_capa *capa =
+		rdev->wiphy.ftm_initiator_capa;
+	int err;
+
+	err = nla_parse_nested(tb, NL80211_FTM_TARGET_ATTR_MAX, ftm_target_attr,
+			       nl80211_ftm_target_policy);
+	if (err)
+		return err;
+
+	if (!tb[NL80211_FTM_TARGET_ATTR_BSSID] ||
+	    !tb[NL80211_FTM_TARGET_ATTR_FREQ] ||
+	    !tb[NL80211_FTM_TARGET_ATTR_BW])
+		return -EINVAL;
+
+	nla_memcpy(target->bssid, tb[NL80211_FTM_TARGET_ATTR_BSSID], ETH_ALEN);
+
+	target->chan_def.chan = ieee80211_get_channel(&rdev->wiphy,
+		nla_get_u32(tb[NL80211_FTM_TARGET_ATTR_FREQ]));
+	if (!target->chan_def.chan)
+		return -EINVAL;
+
+	target->chan_def.width = nla_get_u8(tb[NL80211_FTM_TARGET_ATTR_BW]);
+
+	if (tb[NL80211_FTM_TARGET_ATTR_CNTR_FREQ_1])
+		target->chan_def.center_freq1 =
+			nla_get_u32(tb[NL80211_FTM_TARGET_ATTR_CNTR_FREQ_1]);
+	else
+		target->chan_def.center_freq1 =
+			target->chan_def.chan->center_freq;
+
+	if (tb[NL80211_FTM_TARGET_ATTR_CNTR_FREQ_2])
+		target->chan_def.center_freq2 =
+			nla_get_u32(tb[NL80211_FTM_TARGET_ATTR_CNTR_FREQ_2]);
+
+	if (!cfg80211_chandef_valid(&target->chan_def))
+		return -EINVAL;
+
+	if (tb[NL80211_FTM_TARGET_ATTR_NUM_OF_BURSTS_EXP])
+		target->num_of_bursts_exp =
+		      nla_get_u8(tb[NL80211_FTM_TARGET_ATTR_NUM_OF_BURSTS_EXP]);
+
+	if (target->num_of_bursts_exp != 0) {
+		if (!tb[NL80211_FTM_TARGET_ATTR_BURST_PERIOD])
+			return -EINVAL;
+		target->burst_period =
+			nla_get_u16(tb[NL80211_FTM_TARGET_ATTR_BURST_PERIOD]);
+		if (!target->burst_period)
+			return -EINVAL;
+	}
+
+	target->samples_per_burst =
+		tb[NL80211_FTM_TARGET_ATTR_SAMPLES_PER_BURST] ?
+		nla_get_u8(tb[NL80211_FTM_TARGET_ATTR_SAMPLES_PER_BURST]) : 2;
+
+	if (!tb[NL80211_FTM_TARGET_ATTR_RETRIES])
+		target->retries = 3;
+	else
+		target->retries =
+			nla_get_u8(tb[NL80211_FTM_TARGET_ATTR_RETRIES]);
+
+	target->burst_duration =
+		tb[NL80211_FTM_TARGET_ATTR_BURST_DURATION] ?
+		nla_get_u8(tb[NL80211_FTM_TARGET_ATTR_BURST_DURATION]) : 15;
+
+	target->one_sided = nla_get_flag(tb[NL80211_FTM_TARGET_ATTR_ONE_SIDED]);
+	target->asap = nla_get_flag(tb[NL80211_FTM_TARGET_ATTR_ASAP]);
+	target->lci = nla_get_flag(tb[NL80211_FTM_TARGET_ATTR_QUERY_LCI]);
+	target->civic = nla_get_flag(tb[NL80211_FTM_TARGET_ATTR_QUERY_CIVIC]);
+
+	if (tb[NL80211_FTM_TARGET_ATTR_COOKIE])
+		target->cookie =
+			nla_get_u64(tb[NL80211_FTM_TARGET_ATTR_COOKIE]);
+	if (tb[NL80211_FTM_TARGET_ATTR_FTM_PREAMBLE])
+		target->ftm_preamble =
+			nla_get_u8(tb[NL80211_FTM_TARGET_ATTR_FTM_PREAMBLE]);
+	if (tb[NL80211_FTM_TARGET_ATTR_FTM_BW])
+		target->ftm_bw =
+			nla_get_u8(tb[NL80211_FTM_TARGET_ATTR_FTM_BW]);
+
+	if ((target->asap && !capa->asap) ||
+	    (!target->asap && !capa->non_asap) ||
+	    (target->lci && !capa->req_lci) ||
+	    (target->civic && !capa->req_civic) ||
+	    ((target->ftm_preamble & capa->preamble) != target->ftm_preamble) ||
+	    ((target->ftm_bw & capa->bw) != target->ftm_bw))
+		return -ENOTSUPP;
+
+	return 0;
+}
+
+/* policy for the ftm request attributes */
+static const struct nla_policy
+nl80211_ftm_request_policy[NL80211_FTM_REQ_ATTR_MAX + 1] = {
+	[NL80211_FTM_REQ_ATTR_TIMEOUT] = { .type = NLA_U8 },
+	[NL80211_FTM_REQ_ATTR_MACADDR_TEMPLATE] = { .len = ETH_ALEN  },
+	[NL80211_FTM_REQ_ATTR_MACADDR_MASK] = { .len = ETH_ALEN  },
+	[NL80211_FTM_REQ_ATTR_REPORT_TSF] = { .type = NLA_FLAG },
+	[NL80211_FTM_REQ_ATTR_TARGETS] = { .type = NLA_NESTED },
+};
+
+static int nl80211_parse_ftm_request(struct cfg80211_registered_device *rdev,
+				     struct nlattr *ftm_attr,
+				     struct cfg80211_ftm_request *ftm)
+{
+	struct nlattr *tb[NL80211_FTM_REQ_ATTR_MAX + 1];
+	struct nlattr *ap_attr;
+	int tmp, i, two_sided_counter;
+	int err;
+	const struct wiphy_ftm_initiator_capa *capa =
+		rdev->wiphy.ftm_initiator_capa;
+
+	err = nla_parse_nested(tb, NL80211_FTM_REQ_ATTR_MAX, ftm_attr,
+			       nl80211_ftm_request_policy);
+	if (err)
+		return err;
+
+	if (!tb[NL80211_FTM_REQ_ATTR_MACADDR_TEMPLATE] ||
+	    !tb[NL80211_FTM_REQ_ATTR_MACADDR_MASK] ||
+	    !tb[NL80211_FTM_REQ_ATTR_TARGETS])
+		return -EINVAL;
+
+	if (nl80211_parse_random_mac(tb[NL80211_FTM_REQ_ATTR_MACADDR_TEMPLATE],
+				     tb[NL80211_FTM_REQ_ATTR_MACADDR_MASK],
+				     ftm->macaddr_template, ftm->macaddr_mask))
+		return -EINVAL;
+
+	if (!tb[NL80211_FTM_REQ_ATTR_TIMEOUT])
+		ftm->timeout = 9;
+	else
+		ftm->timeout = nla_get_u8(tb[NL80211_FTM_REQ_ATTR_TIMEOUT]);
+
+	if (tb[NL80211_FTM_REQ_ATTR_REPORT_TSF]) {
+		if (!capa->req_tsf)
+			return -ENOTSUPP;
+		ftm->report_tsf = true;
+	}
+
+	nla_for_each_nested(ap_attr, tb[NL80211_FTM_REQ_ATTR_TARGETS], tmp)
+		ftm->num_of_targets++;
+	ftm->targets = kcalloc(ftm->num_of_targets,
+			       sizeof(struct cfg80211_ftm_target), GFP_KERNEL);
+	if (!ftm->targets)
+		return -ENOMEM;
+
+	i = 0;
+	two_sided_counter = 0;
+	nla_for_each_nested(ap_attr, tb[NL80211_FTM_REQ_ATTR_TARGETS], tmp) {
+		err = nl80211_parse_ftm_target(rdev, ap_attr, &ftm->targets[i]);
+		if (err)
+			goto free_targets;
+		if (!ftm->targets[i].one_sided)
+			two_sided_counter++;
+		i++;
+	}
+	if (ftm->num_of_targets > capa->max_total_ftm_targets ||
+	    two_sided_counter > capa->max_two_sided_ftm_targets) {
+		err = -E2BIG;
+		goto free_targets;
+	}
+
+	return 0;
+
+free_targets:
+	kfree(ftm->targets);
+	return err;
+}
+
+static void nl80211_msrment_request_free(struct cfg80211_msrment_request *req)
+{
+	switch (req->type) {
+	case NL80211_MSRMENT_TYPE_FTM:
+		kfree(req->u.ftm.targets);
+		req->u.ftm.targets = NULL;
+		break;
+	default:
+		break;
+	}
+}
+
+static int nl80211_msrment_request(struct sk_buff *skb, struct genl_info *info)
+{
+	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+	struct net_device *dev = info->user_ptr[1];
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	struct cfg80211_msrment_request request = {0};
+	struct cfg80211_active_msrment *msrment = NULL;
+	struct sk_buff *msg;
+	void *hdr;
+	u64 cookie = 0;
+	int err;
+
+	if (!info->attrs[NL80211_ATTR_MSRMENT_TYPE])
+		return -EINVAL;
+	request.type = nla_get_u32(info->attrs[NL80211_ATTR_MSRMENT_TYPE]);
+	request.nl_portid = genl_info_snd_portid(info);
+
+	switch (request.type) {
+	case NL80211_MSRMENT_TYPE_FTM:
+		if (!info->attrs[NL80211_ATTR_MSRMENT_FTM_REQUEST])
+			return -EINVAL;
+		err = nl80211_parse_ftm_request(rdev,
+			info->attrs[NL80211_ATTR_MSRMENT_FTM_REQUEST],
+			&request.u.ftm);
+		if (err)
+			return err;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	msrment = kzalloc(sizeof(*msrment), GFP_KERNEL);
+	if (!msrment) {
+		err = -ENOMEM;
+		goto free_request;
+	}
+
+	err = rdev_perform_msrment(rdev, wdev, &request, &cookie);
+	if (err)
+		goto free_request;
+
+	WARN_ON(!cookie);
+
+	msrment->wdev = wdev;
+	msrment->cookie = cookie;
+	msrment->nl_portid = genl_info_snd_portid(info);
+
+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	if (!msg) {
+		err = -ENOMEM;
+		goto free_request;
+	}
+
+	hdr = nl80211hdr_put(msg, genl_info_snd_portid(info), info->snd_seq, 0,
+			     NL80211_CMD_MSRMENT_REQUEST);
+	if (!hdr || nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,
+				      NL80211_ATTR_PAD)) {
+		err = -ENOBUFS;
+		goto free_msg;
+	}
+
+	genlmsg_end(msg, hdr);
+
+	spin_lock_bh(&rdev->msrments_lock);
+	list_add_tail(&msrment->list, &rdev->msrments_list);
+	spin_unlock_bh(&rdev->msrments_lock);
+
+	return genlmsg_reply(msg, info);
+
+free_msg:
+	nlmsg_free(msg);
+free_request:
+	kfree(msrment);
+	nl80211_msrment_request_free(&request);
+	return err;
+}
+
+static int nl80211_start_ftm_responder(struct sk_buff *skb,
+				       struct genl_info *info)
+{
+	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+	struct net_device *dev = info->user_ptr[1];
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	struct cfg80211_ftm_responder_params params = {};
+	int err;
+
+	if (wdev->iftype != NL80211_IFTYPE_AP || !wdev->beacon_interval)
+		return -EOPNOTSUPP;
+
+	if (info->attrs[NL80211_ATTR_LCI]) {
+		if (nla_len(info->attrs[NL80211_ATTR_LCI]) > U8_MAX)
+			return -EINVAL;
+
+		params.lci = nla_data(info->attrs[NL80211_ATTR_LCI]);
+		params.lci_len = nla_len(info->attrs[NL80211_ATTR_LCI]);
+	}
+
+	if (info->attrs[NL80211_ATTR_CIVIC]) {
+		if (nla_len(info->attrs[NL80211_ATTR_CIVIC]) > U8_MAX)
+			return -EINVAL;
+
+		params.civic = nla_data(info->attrs[NL80211_ATTR_CIVIC]);
+		params.civic_len = nla_len(info->attrs[NL80211_ATTR_CIVIC]);
+	}
+
+	wdev_lock(wdev);
+	err = rdev_start_ftm_responder(rdev, dev, &params);
+	wdev_unlock(wdev);
+
+	return err;
+}
+
+static int nl80211_get_ftm_responder(struct sk_buff *skb,
+				     struct genl_info *info)
+{
+	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+	struct net_device *dev = info->user_ptr[1];
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	struct cfg80211_ftm_responder_stats ftm_stats;
+	struct sk_buff *msg;
+	void *hdr;
+	struct nlattr *ftm_stats_attr;
+	int err;
+
+	memset(&ftm_stats, 0, sizeof(ftm_stats));
+
+	if (wdev->iftype != NL80211_IFTYPE_AP || !wdev->beacon_interval)
+		return -EOPNOTSUPP;
+
+	err = rdev_get_ftm_responder_stats(rdev, dev, &ftm_stats);
+	if (err)
+		return err;
+
+	if (!ftm_stats.filled)
+		return -ENODATA;
+
+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	hdr = nl80211hdr_put(msg, genl_info_snd_portid(info), info->snd_seq, 0,
+			     NL80211_CMD_GET_FTM_RESPONDER_STATS);
+	if (!hdr)
+		return -ENOBUFS;
+
+	if (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))
+		goto nla_put_failure;
+
+	ftm_stats_attr = nla_nest_start(msg, NL80211_ATTR_FTM_RESPONDER_STATS);
+	if (!ftm_stats_attr)
+		goto nla_put_failure;
+
+#define SET_FTM(field, flag, type)					\
+	if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## flag)) &&	\
+	    nla_put_ ## type(msg, NL80211_FTM_STATS_ ## flag,		\
+			     ftm_stats.field))				\
+		goto nla_put_failure
+#define SET_FTM_U64(field, flag)					\
+	if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## flag)) &&	\
+	    nla_put_u64_64bit(msg, NL80211_FTM_STATS_ ## flag,		\
+			      ftm_stats.field, NL80211_FTM_STATS_PAD))	\
+		goto nla_put_failure
+
+	SET_FTM(success_num, SUCCESS_NUM, u32);
+	SET_FTM(partial_num, PARTIAL_NUM, u32);
+	SET_FTM(failed_num, FAILED_NUM, u32);
+	SET_FTM(asap_num, ASAP_NUM, u32);
+	SET_FTM(non_asap_num, NON_ASAP_NUM, u32);
+	SET_FTM_U64(total_duration_ms, TOTAL_DURATION_MSEC);
+	SET_FTM(unknown_triggers_num, UNKNOWN_TRIGGERS_NUM, u32);
+	SET_FTM(reschedule_requests_num, RESCHEDULE_REQUESTS_NUM, u32);
+	SET_FTM(out_of_window_triggers_num, OUT_OF_WINDOW_TRIGGERS_NUM, u32);
+#undef SET_FTM
+
+	nla_nest_end(msg, ftm_stats_attr);
+
+	genlmsg_end(msg, hdr);
+	return genlmsg_reply(msg, info);
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
 #define NL80211_FLAG_NEED_WIPHY		0x01
 #define NL80211_FLAG_NEED_NETDEV	0x02
 #define NL80211_FLAG_NEED_RTNL		0x04
@@ -12651,6 +13119,29 @@ static __genl_const struct genl_ops nl80
 		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
 				  NL80211_FLAG_NEED_RTNL,
 	},
+	{
+		.cmd = NL80211_CMD_MSRMENT_REQUEST,
+		.doit = nl80211_msrment_request,
+		.policy = nl80211_policy,
+		.flags = GENL_ADMIN_PERM,
+		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
+				  NL80211_FLAG_NEED_RTNL,
+	},
+	{
+		.cmd = NL80211_CMD_START_FTM_RESPONDER,
+		.doit = nl80211_start_ftm_responder,
+		.policy = nl80211_policy,
+		.flags = GENL_ADMIN_PERM,
+		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
+				  NL80211_FLAG_NEED_RTNL,
+	},
+	{
+		.cmd = NL80211_CMD_GET_FTM_RESPONDER_STATS,
+		.doit = nl80211_get_ftm_responder,
+		.policy = nl80211_policy,
+		.internal_flags = NL80211_FLAG_NEED_NETDEV |
+				  NL80211_FLAG_NEED_RTNL,
+	},
 };
 
 /* notification functions */
@@ -14443,6 +14934,7 @@ static int nl80211_netlink_notify(struct
 		bool schedule_scan_stop = false;
 		struct cfg80211_sched_scan_request *sched_scan_req =
 			rcu_dereference(rdev->sched_scan_req);
+		struct cfg80211_active_msrment *msrment;
 
 		if (sched_scan_req && netlink_notify_portid(notify) &&
 		    sched_scan_req->owner_nlportid == netlink_notify_portid(notify))
@@ -14467,6 +14959,16 @@ static int nl80211_netlink_notify(struct
 		}
 		spin_unlock_bh(&rdev->beacon_registrations_lock);
 
+		spin_lock_bh(&rdev->msrments_lock);
+		list_for_each_entry(msrment, &rdev->msrments_list, list) {
+			if (msrment->nl_portid ==
+			    netlink_notify_portid(notify)) {
+				msrment->nl_portid = 0;
+				schedule_work(&rdev->msrment_abort_wk);
+			}
+		}
+		spin_unlock_bh(&rdev->msrments_lock);
+
 		if (schedule_destroy_work) {
 			struct cfg80211_iface_destroy *destroy;
 
@@ -14584,6 +15086,251 @@ void cfg80211_crit_proto_stopped(struct
 }
 EXPORT_SYMBOL(cfg80211_crit_proto_stopped);
 
+static int nl80211_put_ftm_resp_target(struct sk_buff *msg,
+				       struct cfg80211_ftm_target *target)
+{
+	struct nlattr *attr =
+		nla_nest_start(msg, NL80211_FTM_RESP_ENTRY_ATTR_TARGET);
+
+	if (!attr)
+		return -ENOBUFS;
+
+	if (nla_put_u32(msg, NL80211_FTM_TARGET_ATTR_FREQ,
+			target->chan_def.chan->center_freq) ||
+	    nla_put_u8(msg, NL80211_FTM_TARGET_ATTR_BW,
+		       target->chan_def.width) ||
+	    nla_put_u32(msg, NL80211_FTM_TARGET_ATTR_CNTR_FREQ_1,
+			target->chan_def.center_freq1) ||
+	    nla_put_u32(msg, NL80211_FTM_TARGET_ATTR_CNTR_FREQ_2,
+			target->chan_def.center_freq2) ||
+	    nla_put(msg, NL80211_FTM_TARGET_ATTR_BSSID, ETH_ALEN,
+		    target->bssid) ||
+	    nla_put_u8(msg, NL80211_FTM_TARGET_ATTR_NUM_OF_BURSTS_EXP,
+		       target->num_of_bursts_exp) ||
+	    nla_put_u16(msg, NL80211_FTM_TARGET_ATTR_BURST_PERIOD,
+			target->burst_period) ||
+	    nla_put_u8(msg, NL80211_FTM_TARGET_ATTR_SAMPLES_PER_BURST,
+		       target->samples_per_burst) ||
+	    nla_put_u8(msg, NL80211_FTM_TARGET_ATTR_RETRIES, target->retries) ||
+	    nla_put_u8(msg, NL80211_FTM_TARGET_ATTR_BURST_DURATION,
+		       target->burst_duration) ||
+	    nla_put_u64_64bit(msg, NL80211_FTM_TARGET_ATTR_COOKIE,
+			      target->cookie, NL80211_FTM_TARGET_ATTR_PAD) ||
+	    nla_put_u8(msg, NL80211_FTM_TARGET_ATTR_FTM_PREAMBLE,
+		       target->ftm_preamble) ||
+	    nla_put_u8(msg, NL80211_FTM_TARGET_ATTR_FTM_BW,
+		       target->ftm_bw))
+		return -ENOBUFS;
+
+	if (target->one_sided &&
+	    nla_put_flag(msg, NL80211_FTM_TARGET_ATTR_ONE_SIDED))
+		return -ENOBUFS;
+
+	if (target->asap && nla_put_flag(msg, NL80211_FTM_TARGET_ATTR_ASAP))
+		return -ENOBUFS;
+
+	if (target->lci && nla_put_flag(msg, NL80211_FTM_TARGET_ATTR_QUERY_LCI))
+		return -ENOBUFS;
+
+	if (target->civic &&
+	    nla_put_flag(msg, NL80211_FTM_TARGET_ATTR_QUERY_CIVIC))
+		return -ENOBUFS;
+
+	nla_nest_end(msg, attr);
+	return 0;
+}
+
+static int nl80211_put_ftm_result(struct sk_buff *msg,
+				  struct cfg80211_ftm_result *ftm)
+{
+	struct nlattr *resp = nla_nest_start(msg,
+					     NL80211_ATTR_MSRMENT_FTM_RESPONSE);
+
+	if (!resp)
+		return -ENOBUFS;
+
+#define FTM_RES_FILLED(attr) \
+	(ftm->filled & BIT(NL80211_FTM_RESP_ENTRY_ATTR_##attr))
+
+#define PUT_FTM_RES(field, attr, type)					\
+	(FTM_RES_FILLED(attr) &&					\
+	 nla_put_##type(msg, NL80211_FTM_RESP_ENTRY_ATTR_##attr,	\
+			ftm->field))
+#define PUT_FTM_RES_U64(field, attr)					\
+	(FTM_RES_FILLED(attr) &&					\
+	 nla_put_u64_64bit(msg, NL80211_FTM_RESP_ENTRY_ATTR_##attr,	\
+			   ftm->field, NL80211_FTM_RESP_ENTRY_ATTR_PAD))
+
+	if (nla_put_u8(msg, NL80211_FTM_RESP_ENTRY_ATTR_STATUS, ftm->status) ||
+	    (ftm->complete &&
+	     nla_put_flag(msg, NL80211_FTM_RESP_ENTRY_ATTR_COMPLETE)) ||
+	    nl80211_put_ftm_resp_target(msg, ftm->target) ||
+	    nla_put_s64(msg, NL80211_FTM_RESP_ENTRY_ATTR_RTT, ftm->rtt,
+			NL80211_FTM_RESP_ENTRY_ATTR_PAD) ||
+	    PUT_FTM_RES_U64(host_time, HOST_TIME) ||
+	    PUT_FTM_RES_U64(tsf, TSF) ||
+	    PUT_FTM_RES(burst_index, BURST_INDEX, u8) ||
+	    PUT_FTM_RES(measurement_num, MSRMNT_NUM, u32) ||
+	    PUT_FTM_RES(success_num, SUCCESS_NUM, u32) ||
+	    PUT_FTM_RES(num_per_burst, NUM_PER_BURST, u8) ||
+	    PUT_FTM_RES(retry_after_duration, RETRY_DUR, u8) ||
+	    PUT_FTM_RES(burst_duration, BURST_DUR, u32) ||
+	    PUT_FTM_RES(negotiated_burst_num, NEG_BURST_NUM, u32) ||
+	    PUT_FTM_RES(rssi, RSSI, s8) ||
+	    PUT_FTM_RES(rssi_spread, RSSI_SPREAD, u8) ||
+	    PUT_FTM_RES_U64(rtt_variance, RTT_VAR) ||
+	    PUT_FTM_RES_U64(rtt_spread, RTT_SPREAD) ||
+	    PUT_FTM_RES_U64(distance, DISTANCE) ||
+	    PUT_FTM_RES_U64(distance_variance, DISTANCE_VAR) ||
+	    PUT_FTM_RES_U64(distance_spread, DISTANCE_SPREAD) ||
+	    (FTM_RES_FILLED(TX_RATE_INFO) &&
+	     !nl80211_put_sta_rate(msg, &ftm->tx_rate_info,
+				   NL80211_FTM_RESP_ENTRY_ATTR_TX_RATE_INFO)) ||
+	    (FTM_RES_FILLED(RX_RATE_INFO) &&
+	     !nl80211_put_sta_rate(msg, &ftm->rx_rate_info,
+				   NL80211_FTM_RESP_ENTRY_ATTR_RX_RATE_INFO)) ||
+	    (ftm->lci && nla_put(msg, NL80211_FTM_RESP_ENTRY_ATTR_LCI,
+				 ftm->lci_len, ftm->lci)) ||
+	    (ftm->civic && nla_put(msg, NL80211_FTM_RESP_ENTRY_ATTR_CIVIC,
+				   ftm->civic_len, ftm->civic)))
+		return -ENOBUFS;
+#undef PUT_FTM_RES
+#undef FTM_RES_FILLED
+
+	nla_nest_end(msg, resp);
+
+	return 0;
+}
+
+static struct sk_buff *
+nl80211_alloc_measurement_response(struct wiphy *wiphy,
+				   struct cfg80211_msrment_response *response,
+				   void **hdr, gfp_t gfp)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+	struct sk_buff *msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
+
+	if (!msg)
+		return NULL;
+
+	*hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_MSRMENT_RESPONSE);
+	if (!*hdr)
+		goto nla_put_failure;
+
+	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
+	    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, response->cookie,
+			      NL80211_ATTR_PAD) ||
+	    nla_put_u32(msg, NL80211_ATTR_MSRMENT_TYPE, response->type) ||
+	    nla_put_u8(msg, NL80211_ATTR_MSRMENT_STATUS, response->status))
+		goto nla_put_failure;
+
+	return msg;
+
+nla_put_failure:
+	WARN_ON(1);
+	nlmsg_free(msg);
+	return NULL;
+}
+
+static void
+nl80211_send_measurement_response(struct wiphy *wiphy,
+				  struct cfg80211_msrment_response *response,
+				  struct sk_buff *msg, void *hdr)
+{
+	genlmsg_end(msg, hdr);
+	genlmsg_unicast(wiphy_net(wiphy), msg, response->nl_portid);
+}
+
+static void
+nl80211_send_single_ftm_resp(struct wiphy *wiphy,
+			     struct cfg80211_msrment_response *response,
+			     struct cfg80211_ftm_result *entry, bool last,
+			     gfp_t gfp)
+{
+	void *hdr;
+	struct sk_buff *msg = nl80211_alloc_measurement_response(wiphy,
+								 response, &hdr,
+								 gfp);
+	if (!msg)
+		return;
+
+	if (entry && nl80211_put_ftm_result(msg, entry))
+		goto nla_put_failure;
+
+	if (last && nla_put_flag(msg, NL80211_ATTR_LAST_MSG))
+		goto nla_put_failure;
+
+	nl80211_send_measurement_response(wiphy, response, msg, hdr);
+
+	return;
+
+nla_put_failure:
+	WARN_ON(1);
+	nlmsg_free(msg);
+}
+
+static void nl80211_ftm_response(struct wiphy *wiphy,
+				 struct cfg80211_msrment_response *response,
+				 gfp_t gfp)
+{
+	struct cfg80211_ftm_results ftm = response->u.ftm;
+	int i;
+
+	if ((response->status != NL80211_MSRMENT_STATUS_SUCCESS &&
+	     response->status != NL80211_MSRMENT_STATUS_TIMEOUT) ||
+	    ftm.num_of_entries == 0) {
+		nl80211_send_single_ftm_resp(wiphy, response, NULL, true, gfp);
+		return;
+	}
+
+	for (i = 0; i < ftm.num_of_entries; i++) {
+		nl80211_send_single_ftm_resp(wiphy, response, &ftm.entries[i],
+					     (i == ftm.num_of_entries - 1),
+					     gfp);
+	}
+
+	return;
+
+}
+
+void cfg80211_measurement_response(struct wiphy *wiphy,
+				   struct cfg80211_msrment_response *response,
+				   gfp_t gfp)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+	struct cfg80211_active_msrment *tmp, *msrment = NULL;
+
+	trace_cfg80211_measurement_response(wiphy, response);
+
+	spin_lock_bh(&rdev->msrments_lock);
+	list_for_each_entry(tmp, &rdev->msrments_list, list) {
+		if (tmp->cookie == response->cookie) {
+			msrment = tmp;
+			list_del(&tmp->list);
+			break;
+		}
+	}
+	spin_unlock_bh(&rdev->msrments_lock);
+
+	/* if not found or no portid it was canceled already */
+	if (!msrment || !msrment->nl_portid)
+		goto free;
+
+	response->nl_portid = msrment->nl_portid;
+
+	switch (response->type) {
+	case NL80211_MSRMENT_TYPE_FTM:
+		nl80211_ftm_response(wiphy, response, gfp);
+		break;
+	default:
+		WARN(1, "invalid measurement type %d\n", response->type);
+		break;
+	};
+ free:
+	kfree(msrment);
+}
+EXPORT_SYMBOL(cfg80211_measurement_response);
+
 void nl80211_send_ap_stopped(struct wireless_dev *wdev)
 {
 	struct wiphy *wiphy = wdev->wiphy;
--- a/net/wireless/rdev-ops.h
+++ b/net/wireless/rdev-ops.h
@@ -1129,4 +1129,61 @@ rdev_set_coalesce(struct cfg80211_regist
 	trace_rdev_return_int(&rdev->wiphy, ret);
 	return ret;
 }
+
+static inline int rdev_perform_msrment(struct cfg80211_registered_device *rdev,
+				       struct wireless_dev *wdev,
+				       struct cfg80211_msrment_request *request,
+				       u64 *cookie)
+{
+	int ret = -ENOTSUPP;
+
+	trace_rdev_perform_msrment(&rdev->wiphy, wdev, request);
+	if (rdev->ops->perform_msrment)
+		ret = rdev->ops->perform_msrment(&rdev->wiphy, wdev,
+						 request, cookie);
+	trace_rdev_return_int_cookie(&rdev->wiphy, ret, *cookie);
+	return ret;
+}
+
+static inline int rdev_abort_msrment(struct cfg80211_registered_device *rdev,
+				     struct wireless_dev *wdev, u64 cookie)
+{
+	int ret = -ENOTSUPP;
+
+	trace_rdev_abort_msrment(&rdev->wiphy, wdev, cookie);
+	if (rdev->ops->abort_msrment)
+		ret = rdev->ops->abort_msrment(&rdev->wiphy, wdev, cookie);
+	trace_rdev_return_int(&rdev->wiphy, ret);
+	return ret;
+}
+
+static inline int
+rdev_start_ftm_responder(struct cfg80211_registered_device *rdev,
+			 struct net_device *dev,
+			 struct cfg80211_ftm_responder_params *params)
+{
+	int ret = -EOPNOTSUPP;
+
+	trace_rdev_start_ftm_responder(&rdev->wiphy, dev, params);
+	if (rdev->ops->start_ftm_responder)
+		ret = rdev->ops->start_ftm_responder(&rdev->wiphy, dev, params);
+	trace_rdev_return_int(&rdev->wiphy, ret);
+	return ret;
+}
+
+static inline int
+rdev_get_ftm_responder_stats(struct cfg80211_registered_device *rdev,
+			     struct net_device *dev,
+			     struct cfg80211_ftm_responder_stats *ftm_stats)
+{
+	int ret = -EOPNOTSUPP;
+
+	trace_rdev_get_ftm_responder_stats(&rdev->wiphy, dev, ftm_stats);
+	if (rdev->ops->get_ftm_responder_stats)
+		ret = rdev->ops->get_ftm_responder_stats(&rdev->wiphy, dev,
+							ftm_stats);
+	trace_rdev_return_int(&rdev->wiphy, ret);
+	return ret;
+}
+
 #endif /* __CFG80211_RDEV_OPS */
--- a/net/wireless/trace.h
+++ b/net/wireless/trace.h
@@ -289,6 +289,16 @@ DECLARE_EVENT_CLASS(wiphy_only_evt,
 	TP_printk(WIPHY_PR_FMT, WIPHY_PR_ARG)
 );
 
+DEFINE_EVENT(wiphy_only_evt, rdev_suspend_enter,
+	TP_PROTO(struct wiphy *wiphy),
+	TP_ARGS(wiphy)
+);
+
+DEFINE_EVENT(wiphy_only_evt, rdev_suspend_leave,
+	TP_PROTO(struct wiphy *wiphy),
+	TP_ARGS(wiphy)
+);
+
 DEFINE_EVENT(wiphy_only_evt, rdev_resume,
 	TP_PROTO(struct wiphy *wiphy),
 	TP_ARGS(wiphy)
@@ -2212,6 +2222,112 @@ TRACE_EVENT(rdev_tdls_cancel_channel_swi
 		  WIPHY_PR_ARG, NETDEV_PR_ARG, MAC_PR_ARG(addr))
 );
 
+TRACE_EVENT(rdev_perform_msrment,
+	TP_PROTO(struct wiphy *wiphy, struct wireless_dev *wdev,
+		 struct cfg80211_msrment_request *request),
+	TP_ARGS(wiphy, wdev, request),
+	TP_STRUCT__entry(
+		WIPHY_ENTRY
+		WDEV_ENTRY
+		__field(enum nl80211_msrment_type, type)
+	),
+	TP_fast_assign(
+		WIPHY_ASSIGN;
+		WDEV_ASSIGN;
+		__entry->type = request->type;
+	),
+	TP_printk(WIPHY_PR_FMT ", " WDEV_PR_FMT ", type %d",
+		  WIPHY_PR_ARG, WDEV_PR_ARG, __entry->type)
+);
+
+TRACE_EVENT(rdev_abort_msrment,
+	TP_PROTO(struct wiphy *wiphy, struct wireless_dev *wdev, u64 cookie),
+	TP_ARGS(wiphy, wdev, cookie),
+	TP_STRUCT__entry(
+		WIPHY_ENTRY
+		WDEV_ENTRY
+		__field(u64, cookie)
+	),
+	TP_fast_assign(
+		WIPHY_ASSIGN;
+		WDEV_ASSIGN;
+		__entry->cookie = cookie;
+	),
+	TP_printk(WIPHY_PR_FMT ", " WDEV_PR_FMT ", cookie %llu",
+		  WIPHY_PR_ARG, WDEV_PR_ARG, __entry->cookie)
+);
+
+TRACE_EVENT(rdev_start_ftm_responder,
+	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
+		 struct cfg80211_ftm_responder_params *params),
+	TP_ARGS(wiphy, netdev, params),
+	TP_STRUCT__entry(
+		WIPHY_ENTRY
+		NETDEV_ENTRY
+		CHAN_DEF_ENTRY
+		__dynamic_array(u8, lci, params->lci_len)
+		__dynamic_array(u8, civic, params->civic_len)
+	),
+	TP_fast_assign(
+		WIPHY_ASSIGN;
+		NETDEV_ASSIGN;
+		memcpy(__get_dynamic_array(lci), params->lci, params->lci_len);
+		memcpy(__get_dynamic_array(civic), params->civic,
+		       params->civic_len);
+	),
+	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT
+		  "lci %s civic %s", WIPHY_PR_ARG,
+		  NETDEV_PR_ARG,
+		  __print_array(__get_dynamic_array(lci),
+				__get_dynamic_array_len(lci), 1),
+		  __print_array(__get_dynamic_array(civic),
+				__get_dynamic_array_len(civic), 1))
+);
+
+TRACE_EVENT(rdev_get_ftm_responder_stats,
+	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
+		 struct cfg80211_ftm_responder_stats *ftm_stats),
+
+	TP_ARGS(wiphy, netdev, ftm_stats),
+
+	TP_STRUCT__entry(
+		WIPHY_ENTRY
+		NETDEV_ENTRY
+		__field(u64, timestamp)
+		__field(u32, success_num)
+		__field(u32, partial_num)
+		__field(u32, failed_num)
+		__field(u32, asap_num)
+		__field(u32, non_asap_num)
+		__field(u64, duration)
+		__field(u32, unknown_triggers)
+		__field(u32, reschedule)
+		__field(u32, out_of_window)
+	),
+
+	TP_fast_assign(
+		WIPHY_ASSIGN;
+		NETDEV_ASSIGN;
+		__entry->success_num = ftm_stats->success_num;
+		__entry->partial_num = ftm_stats->partial_num;
+		__entry->failed_num = ftm_stats->failed_num;
+		__entry->asap_num = ftm_stats->asap_num;
+		__entry->non_asap_num = ftm_stats->non_asap_num;
+		__entry->duration = ftm_stats->total_duration_ms;
+		__entry->unknown_triggers = ftm_stats->unknown_triggers_num;
+		__entry->reschedule = ftm_stats->reschedule_requests_num;
+		__entry->out_of_window = ftm_stats->out_of_window_triggers_num;
+	),
+
+	TP_printk(WIPHY_PR_FMT "Ftm responder stats: success %u, partial %u, "
+		"failed %u, asap %u, non asap %u, total duration %llu, unknown "
+		"triggers %u, rescheduled %u, out of window %u", WIPHY_PR_ARG,
+		__entry->success_num, __entry->partial_num, __entry->failed_num,
+		__entry->asap_num, __entry->non_asap_num, __entry->duration,
+		__entry->unknown_triggers, __entry->reschedule,
+		__entry->out_of_window)
+);
+
 /*************************************************************
  *	     cfg80211 exported functions traces		     *
  *************************************************************/
@@ -3030,6 +3146,27 @@ DEFINE_EVENT(wiphy_wdev_evt, rdev_abort_
 	TP_PROTO(struct wiphy *wiphy, struct wireless_dev *wdev),
 	TP_ARGS(wiphy, wdev)
 );
+
+TRACE_EVENT(cfg80211_measurement_response,
+	TP_PROTO(struct wiphy *wiphy,
+		 struct cfg80211_msrment_response *response),
+	TP_ARGS(wiphy, response),
+	TP_STRUCT__entry(
+		WIPHY_ENTRY
+		__field(u64, cookie)
+		__field(enum nl80211_msrment_type, type)
+		__field(enum nl80211_msrment_status, status)
+	),
+	TP_fast_assign(
+		WIPHY_ASSIGN;
+		__entry->cookie = response->cookie;
+		__entry->type = response->type;
+		__entry->status = response->status;
+	),
+	TP_printk(WIPHY_PR_FMT ", cookie %llu, type %d, status %d",
+		  WIPHY_PR_ARG, __entry->cookie, __entry->type, __entry->status)
+);
+
 #endif /* !__RDEV_OPS_TRACE || TRACE_HEADER_MULTI_READ */
 
 #undef TRACE_INCLUDE_PATH
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -420,8 +420,8 @@ unsigned int ieee80211_get_mesh_hdrlen(s
 }
 EXPORT_SYMBOL(ieee80211_get_mesh_hdrlen);
 
-static int __ieee80211_data_to_8023(struct sk_buff *skb, struct ethhdr *ehdr,
-				    const u8 *addr, enum nl80211_iftype iftype)
+int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,
+				  const u8 *addr, enum nl80211_iftype iftype)
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
 	struct {
@@ -525,13 +525,7 @@ static int __ieee80211_data_to_8023(stru
 
 	return 0;
 }
-
-int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
-			   enum nl80211_iftype iftype)
-{
-	return __ieee80211_data_to_8023(skb, NULL, addr, iftype);
-}
-EXPORT_SYMBOL(ieee80211_data_to_8023);
+EXPORT_SYMBOL(ieee80211_data_to_8023_exthdr);
 
 int ieee80211_data_from_8023(struct sk_buff *skb, const u8 *addr,
 			     enum nl80211_iftype iftype,
@@ -746,28 +740,18 @@ __ieee80211_amsdu_copy(struct sk_buff *s
 void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
 			      const u8 *addr, enum nl80211_iftype iftype,
 			      const unsigned int extra_headroom,
-			      bool has_80211_header)
+			      const u8 *check_da, const u8 *check_sa)
 {
 	unsigned int hlen = ALIGN(extra_headroom, 4);
 	struct sk_buff *frame = NULL;
 	u16 ethertype;
 	u8 *payload;
-	int offset = 0, remaining, err;
+	int offset = 0, remaining;
 	struct ethhdr eth;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
-	bool reuse_frag = 0;
-#else
 	bool reuse_frag = skb->head_frag && !skb_has_frag_list(skb);
-#endif
 	bool reuse_skb = false;
 	bool last = false;
 
-	if (has_80211_header) {
-		err = __ieee80211_data_to_8023(skb, &eth, addr, iftype);
-		if (err)
-			goto out;
-	}
-
 	while (!last) {
 		unsigned int subframe_len;
 		int len;
@@ -784,8 +768,17 @@ void ieee80211_amsdu_to_8023s(struct sk_
 			goto purge;
 
 		offset += sizeof(struct ethhdr);
-		/* reuse skb for the last subframe */
 		last = remaining <= subframe_len + padding;
+
+		/* FIXME: should we really accept multicast DA? */
+		if ((check_da && !is_multicast_ether_addr(eth.h_dest) &&
+		     !ether_addr_equal(check_da, eth.h_dest)) ||
+		    (check_sa && !ether_addr_equal(check_sa, eth.h_source))) {
+			offset += len + padding;
+			continue;
+		}
+
+		/* reuse skb for the last subframe */
 		if (!skb_is_nonlinear(skb) && !reuse_frag && last) {
 			skb_pull(skb, offset);
 			frame = skb;
@@ -823,7 +816,6 @@ void ieee80211_amsdu_to_8023s(struct sk_
 
  purge:
 	__skb_queue_purge(list);
- out:
 	dev_kfree_skb(skb);
 }
 EXPORT_SYMBOL(ieee80211_amsdu_to_8023s);
--- /dev/null
+++ b/backport-include/linux/scatterlist.h
@@ -0,0 +1,101 @@
+#ifndef __BACKPORT_SCATTERLIST_H
+#define __BACKPORT_SCATTERLIST_H
+#include_next <linux/scatterlist.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0)
+
+/*
+ * sg page iterator
+ *
+ * Iterates over sg entries page-by-page.  On each successful iteration,
+ * @piter->page points to the current page, @piter->sg to the sg holding this
+ * page and @piter->sg_pgoffset to the page's page offset within the sg. The
+ * iteration will stop either when a maximum number of sg entries was reached
+ * or a terminating sg (sg_last(sg) == true) was reached.
+ */
+struct sg_page_iter {
+	struct page             *page;          /* current page */
+	struct scatterlist      *sg;            /* sg holding the page */
+	unsigned int            sg_pgoffset;    /* page offset within the sg */
+
+	/* these are internal states, keep away */
+	unsigned int            __nents;        /* remaining sg entries */
+	int                     __pg_advance;   /* nr pages to advance at the
+						 * next step */
+};
+
+struct backport_sg_mapping_iter {
+	/* the following three fields can be accessed directly */
+	struct page		*page;		/* currently mapped page */
+	void			*addr;		/* pointer to the mapped area */
+	size_t			length;		/* length of the mapped area */
+	size_t			consumed;	/* number of consumed bytes */
+	struct sg_page_iter	piter;		/* page iterator */
+
+	/* these are internal states, keep away */
+	unsigned int		__offset;	/* offset within page */
+	unsigned int		__remaining;	/* remaining bytes on page */
+	unsigned int		__flags;
+};
+#define sg_mapping_iter LINUX_BACKPORT(sg_mapping_iter)
+
+/**
+ * sg_page_iter_page - get the current page held by the page iterator
+ * @piter:	page iterator holding the page
+ */
+static inline struct page *sg_page_iter_page(struct sg_page_iter *piter)
+{
+	return nth_page(sg_page(piter->sg), piter->sg_pgoffset);
+}
+
+bool __sg_page_iter_next(struct sg_page_iter *piter);
+void __sg_page_iter_start(struct sg_page_iter *piter,
+			  struct scatterlist *sglist, unsigned int nents,
+			  unsigned long pgoffset);
+
+void backport_sg_miter_start(struct sg_mapping_iter *miter, struct scatterlist *sgl,
+		    unsigned int nents, unsigned int flags);
+bool backport_sg_miter_next(struct sg_mapping_iter *miter);
+void backport_sg_miter_stop(struct sg_mapping_iter *miter);
+#define sg_miter_start LINUX_BACKPORT(sg_miter_start)
+#define sg_miter_next LINUX_BACKPORT(sg_miter_next)
+#define sg_miter_stop LINUX_BACKPORT(sg_miter_stop)
+
+/**
+ * for_each_sg_page - iterate over the pages of the given sg list
+ * @sglist:    sglist to iterate over
+ * @piter:     page iterator to hold current page, sg, sg_pgoffset
+ * @nents:     maximum number of sg entries to iterate over
+ * @pgoffset:  starting page offset
+ */
+#define for_each_sg_page(sglist, piter, nents, pgoffset)		\
+	for (__sg_page_iter_start((piter), (sglist), (nents), (pgoffset)); \
+	     __sg_page_iter_next(piter);)
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0)
+size_t sg_copy_buffer(struct scatterlist *sgl, unsigned int nents, void *buf,
+		      size_t buflen, off_t skip, bool to_buffer);
+
+#define sg_pcopy_to_buffer LINUX_BACKPORT(sg_pcopy_to_buffer)
+
+static inline
+size_t sg_pcopy_to_buffer(struct scatterlist *sgl, unsigned int nents,
+			  void *buf, size_t buflen, off_t skip)
+{
+	return sg_copy_buffer(sgl, nents, buf, buflen, skip, true);
+}
+
+#define sg_pcopy_from_buffer LINUX_BACKPORT(sg_pcopy_from_buffer)
+
+static inline
+size_t sg_pcopy_from_buffer(struct scatterlist *sgl, unsigned int nents,
+			    void *buf, size_t buflen, off_t skip)
+{
+	return sg_copy_buffer(sgl, nents, buf, buflen, skip, false);
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0) */
+
+#endif /* __BACKPORT_SCATTERLIST_H */
