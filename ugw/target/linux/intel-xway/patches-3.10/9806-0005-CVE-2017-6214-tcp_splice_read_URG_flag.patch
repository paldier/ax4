#CVE-2017-6214
#The tcp_splice_read function in net/ipv4/tcp.c in the Linux kernel before 4.9.11 allows remote attackers to cause a denial of service (infinite loop and soft lockup) via vectors involving a TCP packet with the URG flag.


author	Eric Dumazet <edumazet@google.com>	2017-02-03 14:59:38 -0800
committer	David S. Miller <davem@davemloft.net>	2017-02-06 22:38:55 -0500
commit	ccf7abb93af09ad0868ae9033d1ca8108bdaec82 (patch)
tree	a3d41e0f7a625bc45ea5396cfcf4a400284112cf
parent	b3f2d07f4649adcf6905953a10d217b5683e4077 (diff)
download	linux-ccf7abb93af09ad0868ae9033d1ca8108bdaec82.tar.gz
tcp: avoid infinite loop in tcp_splice_read()
Splicing from TCP socket is vulnerable when a packet with URG flag is
received and stored into receive queue.

__tcp_splice_read() returns 0, and sk_wait_data() immediately
returns since there is the problematic skb in queue.

This is a nice way to burn cpu (aka infinite loop) and trigger
soft lockups.

Again, this gem was found by syzkaller tool.

Fixes: 9c55e01c0cc8 ("[TCP]: Splice receive support.")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Dmitry Vyukov  <dvyukov@google.com>
Cc: Willy Tarreau <w@1wt.eu>
Signed-off-by: David S. Miller <davem@davemloft.net>

--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -754,6 +754,12 @@
 				ret = -EAGAIN;
 				break;
 			}
+			/* if __tcp_splice_read() got nothing while we have
+			 * an skb in receive queue, we do not want to loop.
+			 * This might happen with URG data.
+			 */
+			if (!skb_queue_empty(&sk->sk_receive_queue))
+				break;
 			sk_wait_data(sk, &timeo);
 			if (signal_pending(current)) {
 				ret = sock_intr_errno(timeo);


