#CVE-2017-6346
#Race condition in net/packet/af_packet.c in the Linux kernel before 4.9.13 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a multithreaded application that makes PACKET_FANOUT setsockopt system calls. 


author	Eric Dumazet <edumazet@google.com>	2017-02-14 09:03:51 -0800
committer	David S. Miller <davem@davemloft.net>	2017-02-14 15:05:12 -0500
commit	d199fab63c11998a602205f7ee7ff7c05c97164b (patch)
tree	9977e38c6afb849d7f823820b73d160092415e60
parent	f39f0d1e1e93145a0e91d9a7a639c42fd037ecc3 (diff)
download	linux-d199fab63c11998a602205f7ee7ff7c05c97164b.tar.gz
packet: fix races in fanout_add()
Multiple threads can call fanout_add() at the same time.

We need to grab fanout_mutex earlier to avoid races that could
lead to one thread freeing po->rollover that was set by another thread.

Do the same in fanout_release(), for peace of mind, and to help us
finding lockdep issues earlier.

Fixes: dc99f600698d ("packet: Add fanout support.")
Fixes: 0648ab70afe6 ("packet: rollover prepare: per-socket state")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Willem de Bruijn <willemb@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -1286,6 +1286,7 @@
 
 static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 {
+    struct packet_rollover *rollover = NULL;
 	struct packet_sock *po = pkt_sk(sk);
 	struct packet_fanout *f, *match;
 	u8 type = type_flags & 0xff;
@@ -1303,14 +1304,16 @@
 	default:
 		return -EINVAL;
 	}
+	mutex_lock(&fanout_mutex);
 
+	err = -EINVAL;
 	if (!po->running)
-		return -EINVAL;
+		goto out;
 
+    err = -EALREADY;
 	if (po->fanout)
-		return -EALREADY;
+		goto out;
 
-	mutex_lock(&fanout_mutex);
 	match = NULL;
 	list_for_each_entry(f, &fanout_list, list) {
 		if (f->id == id &&
@@ -1366,18 +1369,18 @@
 	struct packet_sock *po = pkt_sk(sk);
 	struct packet_fanout *f;
 
-	f = po->fanout;
-	if (!f)
-		return;
-
 	mutex_lock(&fanout_mutex);
-	po->fanout = NULL;
 
-	if (atomic_dec_and_test(&f->sk_ref)) {
-		list_del(&f->list);
-		dev_remove_pack(&f->prot_hook);
-		kfree(f);
-	}
+	f = po->fanout;
+	if (f) {
+		po->fanout = NULL;
+
+		if (atomic_dec_and_test(&f->sk_ref)) {
+			list_del(&f->list);
+			dev_remove_pack(&f->prot_hook);
+			kfree(f);
+		}
+    }
 	mutex_unlock(&fanout_mutex);
 }
 

